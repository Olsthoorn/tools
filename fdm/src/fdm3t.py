# %% [markdown]
# # A finite difference model for ransient groundwater flow
#
# The implementation is in the function fdm3t. Some other modules are used
# that are in subdirectories of the tools folder. One may change the line that
# includes the tools folder to an absolute path on a specific computer.
#
# The model has also been wrapped in thte class Fdm3t.
#
# Under __main__ are several tests that have been implemented as functions
# themselves to prevent clutter under __main__.
#
# The data for the different tests are collectd in a dictionary 'cases'.
#
# Just run this file to see a number of example cases comparing with analytical solutions
# %%

# sys.path.insert(0, os.path.abspath('../')) # Start in the subdirectory of tools

import warnings
import numpy as np
import matplotlib.pyplot as plt
import scipy.sparse as sp
from scipy.special import exp1, k0
from scipy.sparse.linalg import spsolve # to use its short name
from scipy.interpolate import RegularGridInterpolator

# In Tools folder:
from analytic.hantush_convolution import Wh
from fdm.src.mfgrid import Grid
from etc import newfig, color_cycler

# --- Check Hantush's well function outcomes
# print('Wh(0.001, 0.3)  =', Wh(0.001, 0.3))
# print('Wh(0.01, 0.3)   =', Wh(0.01, 0.3))
# print('Wh(0.1, 0.3)    =', Wh(0.1, 0.3))

# %%
class InputError(Exception):
    """Define Input Error class."""
    pass

dtypeQ   = np.dtype([('I', np.int32), ('q', float)])
dtypeH   = np.dtype([('I', np.int32), ('h', float)])
dtypeGHB = np.dtype([('I', np.int32), ('h', float), ('C', float)])

def fdm3t(gr=None, t=None, k=None, c=None, ss=None, fh=None, ghb=None,
          fq=None, hi=None, idomain=None, epsilon=0.67):
    """Transient 3D Finite Difference Model as a function, returning computed heads and flows.

    Heads and flows are returned as 3D arrays as specified under output parmeters.

    Steady-state flow is computed when setting Ss = 0 for all Ss and making
    sure at least one cell has a fixed head, i.e. one with FH specified.
    For steady state, also use epsilon = 1, to prevent oscillatioin in the results
    of the first times.

    Parameters
    ----------
    gr : `grid_object`, generated by gr = Grid(x, y, z, ..)
        if `gr.axial`==True, then the model is run in axially symmetric model
    t : ndarray, shape: [Nt+1]
        times at which the heads and flows are desired including the start time,
        which is usually zero, but can have any value.
    k: 2 or 3-tuple of ndarray, shape: (Nz, Ny, Nx), [L/T]
        hydraulic conductivities along the three axes, 3D arrays.
    c: nd.array of shape (Nz-1, Ny, Nx) or (Nz, Nx, Ny) or (Nz+1, Ny, Nx)
        vertical resistances between the layers
            - between the layers if shape(0) == nlay - 1
            - includes above top layer if shape(0) = nlay
            - includes both  top and bottom layers if shape(0) = nlay + 1
        may be None
    ss : ndarray, shape: (Nz, Ny, Nx), [L-1]
        specific elastic storage
    fh : Fixed-flow boundaries dict{ it: recarray, ...}
        recarray with dtype = np.dtype([('I', int), ('h', float)])
    ghb: General head boundaries dict {it: recarray, ...}
        recarray with dtype = np.dtype([(I, 'int'), ('h', float), ('C', float)])
    fq : Fixed-flow boundaries dict{ it: recarray, ...}
        recarray with dtype = np.dtype([('I', int), ('Q', float)])
    fh:  Fixed-head or perscribed heads dict {it: recarray, ....}
        recarray dtype = np.dtype([('I', int), ('h', float)])
    hi : ndarray, shape: (Nz, Ny, Nx), [L]
        initial heads. `IH` has the prescribed heads for the cells with prescribed head.
    idomain : ndarray, shape: (Nz, Ny, Nx) of int
        boundary array like in MF6, flow-through cells not supported
        * idomain=0   cells are inactive, will be given value NaN
        * idomain!=0  cells are active
    epsilon : float, dimension [-]
        degree of implicitness, choose value between 0.5 and 1.0

    outputs
    -------
    out : dictionary gr, time, heads and flows:
        out['gr]: mfgrid.Grid objecy (holding the network)
        out['t']: array of times including the time of the initial head.
        out['Phi'] : ndarray, shape: (Nt+1, Nz, Ny, Nx), [L3/T]
            computed heads. Inactive cells will have NaNs
            To get heads at time t[i], use Out.Phi[i]
            Out.Phi[0] = initial heads
        out['Q']   : ndarray, shape: (Nt, Nz, Ny, Nx), [L3/T]
            net inflow in all cells during time step, inactive cells have 0
            Q during time step i, use Out.Q[i]
        out['Qs']  : ndarray, shape: (Nt, Nz, Ny, Nx), [L3/T]
            release from storage during time step.
        out['Qx']   : ndarray, shape: (Nt, Ny, Nx-1, Nz), [L3/T]
            intercell flows in x-direction (parallel to the rows)
        out['Qy']  : ndarray, shape: (Nt, Ny-1, Nx, Nz), [L3/T]
            intercell flows in y-direction (parallel to the columns)
        out['Qz']  : ndarray, shape: (Nt, Nz, Ny, Nx-1), [L3/T]
            intercell flows in z-direction (vertially upward postitive)
        out['GHB'] : ndarray of gr.shape of general head boundary inflows if GHB is not None.

    TO 161024, 230418
    """
    if gr.axial:
        print('Running in axial mode, y-values are ignored.')

    kx, ky, kz = gr.check_array_tuple(k)

    if c is not None:
        if isinstance(c, np.ndarray):
            if not np.all(c.shape == (gr.nlay -1, gr.ny, gr.nx)):
                raise AssertionError(f"shape c ({c.shape}) should be {(gr.nlay - 1, gr.ny, gr.nx)}")

    active = (idomain != 0).reshape(gr.nod,)  # boolean vector denoting the active cells
    inact  = (idomain == 0).reshape(gr.nod,)  # boolean vector denoting inacive cells

    if fh is not None:
        fh = gr.check_sarray_dict(fh, dtype=dtypeH)
    if fq is not None:
        fq = gr.check_sarray_dict(fq, dtype=dtypeQ)
    if ghb is not None:
        ghb = gr.check_sarray_dict(ghb, dtype=dtypeGHB)

    if ss is None:
        if fh is None and ghb is None:
            raise ValueError('If all ss == 0, at FQ or ghb must be used.')
        epsilon = 1.0 # Prevents oscillations in early times

    # reshaping shorthands
    dx = np.reshape(gr.dx, (1, 1, gr.nx))
    dy = np.reshape(gr.dy, (1, gr.ny, 1))

    # half cell flow resistances
    if not gr.axial:
        rxe = 0.5 *    dx / (   dy * gr.DZ) / kx
        rxw = rxe
        ry = 0.5 *    dy / (gr.DZ *    dx) / ky
        rz = 0.5 * gr.DZ / (   dx *    dy) / kz
        rc  = 0 if c is None else c   / (dx * dy)
    else:
        with warnings.catch_warnings():
            # Division  by zero when x==0, is ok --> np.inf as resistance.
            warnings.simplefilter("ignore", category=RuntimeWarning)
            rxw = 1 / (2 * np.pi * kx * gr.DZ) * np.log(gr.xm / gr.x[:-1]).reshape((1, 1, gr.nx))
            rxe = 1 / (2 * np.pi * kx * gr.DZ) * np.log(gr.x[1:] /  gr.xm).reshape((1, 1, gr.nx))
        ry = np.inf * np.ones(gr.shape)
        rz = 0.5 * gr.DZ / (np.pi * (gr.x[1:] ** 2 - gr.x[:-1] ** 2).reshape((1, 1, gr.nx)) * kz)
        rc  = 0 if c is None else c   / (
            np.pi * (gr.x[1:] ** 2 - gr.x[:-1] ** 2).reshape((1, 1, gr.nx))
            )

    # set flow resistance in inactive cells to infinite
    rxw[inact.reshape(gr.shape)] = np.inf
    rxw[inact.reshape(gr.shape)] = np.inf
    ry[inact.reshape(gr.shape)] = np.inf
    rz[inact.reshape(gr.shape)] = np.inf

    # conductances between adjacent cells
    cx = 1 / (rxw[: , :,1:] + rxe[:  ,:  ,:-1])
    cy = 1 / (ry[: ,1:, :] + ry[:  ,:-1,:  ])
    cz = 1 / (rz[1:, :, :] + rc + rz[:-1,:  ,:  ])

    # storage term, variable dt not included
    if ss is not None:
        Cs = ss * gr.DZ * gr.Area[np.newaxis, :, : ] / epsilon

    # cell number of neighboring cells
    IW = gr.NOD[:,:,:-1]  # east neighbor cell numbers
    IE = gr.NOD[:,:, 1:] # west neighbor cell numbers
    IN = gr.NOD[:,:-1,:] # north neighbor cell numbers
    IS = gr.NOD[:, 1:,:]  # south neighbor cell numbers
    IT = gr.NOD[:-1,:,:] # top neighbor cell numbers
    IB = gr.NOD[ 1:,:,:]  # bottom neighbor cell numbers

    def R(x):
        """Return x.ravel()"""
        return x.ravel()
    
    # notice the call  csc_matrix( (data, (rowind, coind) ), (M,N))  tuple within tupple
    # also notice that Cij = negative but that Cii will be postive, namely -sum(Cij)
    A = sp.csc_matrix(( np.concatenate(( R(cx), R(cx), R(cy), R(cy), R(cz), R(cz)) ),\
                        (np.concatenate(( R(IE), R(IW), R(IN), R(IS), R(IT), R(IB)) ),\
                         np.concatenate(( R(IW), R(IE), R(IS), R(IN), R(IB), R(IT)) ),\
                      )),(gr.nod,gr.nod))

    # Change sign and add diagonal
    A = -A + sp.diags( np.array(A.sum(axis=1)).ravel() )

    #Initialize output arrays (= memory allocation)
    if t is None:
        nt, ndt, t = 2, 1, np.array([0., 1.])
    else:
        nt, ndt = len(t), len(t)-1
    Phi = np.zeros((ndt+1, gr.nod)) # Nt+1 times
    Q   = np.zeros((ndt,   gr.nod)) # Nt time steps
    Qs  = np.zeros((ndt,   gr.nod))
    Qghb= np.zeros((ndt,   gr.nod))

    Qx  = np.zeros((ndt, gr.nz, gr.ny, gr.nx-1))
    Qy  = np.zeros((ndt, gr.nz, gr.ny-1, gr.nx))
    Qz  = np.zeros((ndt, gr.nz-1, gr.ny, gr.nx))

    # reshape input arrays to vectors for use in system equation

    if ss is not None:
        Cs = R(Cs)

    # initialize heads
    if hi is not None:
        Phi[0] = hi.flatten()
    rhs  = np.zeros(gr.shape).flatten()
    fQ   = np.zeros(gr.shape).flatten()
    ghbc = np.zeros(gr.shape).flatten()
    ghbh = np.zeros(gr.shape).flatten()
    dia  = np.zeros(gr.shape).flatten()
    act_it = active[:]

    # solve heads at active locations not fixed head at t_i+eps*dt_i
    for idt, dt in enumerate(np.diff(t)):
        it = idt + 1
        rhs[:] = 0.
        dia[:] = 0.

        if fq is not None:
            if idt in fq: # update fq
                fQ[:] = 0.
                fQ[fq[idt]['I']] = fq[idt]['q']
            if idt >= tuple(fq.keys())[0]:
                rhs += fQ

        if ghb is not None:
            if idt in ghb: # update ghb
                ghbc[:] = 0.
                ghbh[:] = 0.
                ghbc[ghb[idt]['I']] = ghb[idt]['C']
                ghbh[ghb[idt]['I']] = ghb[idt]['h']
            if idt >= tuple(ghb.keys())[0]:
                dia += ghbc
                rhs += ghbc * ghbh

        if ss is not None: # update Cs / dt
            dia += Cs / dt
            rhs += Cs / dt * Phi[it - 1]

        if fh is not None:
            if idt in fh: # update fh
                Ifh, hfh = fh[idt]['I'], fh[idt]['h']
                isfh = gr.const(0., dtype=bool).ravel()
                isfh[Ifh]    = True
            if idt >= tuple(fh.keys())[0]:
                Phi[it][Ifh] = hfh
                fh_rhs = (A + sp.diags(dia))[:, Ifh].dot(Phi[it][Ifh])
                act_it = np.logical_and(active, np.logical_not(isfh))
                rhs -= fh_rhs

        Phi[it][act_it] = spsolve( (A + sp.diags(dia))[act_it][:,act_it], rhs[act_it])

        # net cell inflow
        Q[idt]  = A.dot(Phi[it])

        if ss is not None:
            Qs[idt] = -Cs/dt * (Phi[it]-Phi[it-1])

        #Flows across cell faces
        Qx[idt] =  -np.diff( Phi[it].reshape(gr.shape), axis=2) * cx
        Qy[idt] =  +np.diff( Phi[it].reshape(gr.shape), axis=1) * cy
        Qz[idt] =  +np.diff( Phi[it].reshape(gr.shape), axis=0) * cz

        if ghb is not None:
            Qghb[idt] = (ghbh.ravel() - Phi[it]) * ghbc.ravel()

        # update head to end of time step
        Phi[it][act_it] = Phi[it-1][act_it] + (Phi[it]-Phi[it-1])[act_it] / epsilon
        #Phi[it][active] = Phi[it-1][active] + (Phi[it]-Phi[it-1])[active] / epsilon
        Phi[it][inact]  = np.nan

    # reshape Phi to shape of grid
    Phi  =  Phi.reshape((nt, ) + gr.shape)
    Q    =    Q.reshape((ndt,) + gr.shape)
    Qs   =   Qs.reshape((ndt,) + gr.shape)
    Qghb = Qghb.reshape((ndt,) + gr.shape)

    out = dict()
    out.update(gr=gr, t=t, Phi=Phi, Q=Q, Qs=Qs, Qx=Qx, Qy=Qy, Qz=Qz, Qghb=Qghb)

    return out

class Fdm3t:
    """Class of transient finite difference groundwater model as a class.

    Wraps around the function fdm3t in it.
    """

    def __init__(self, gr=None, k=None, c=None, ss=None, idomain=None, epsilon=1.0):
        """Instantiate a 3D transient axially symmetric groundwater
        finite difference model.

        All model arrays must have shape [nlay, nrow, ncol]. This is so
        even if an axially symmetric model has only one row.

        You can specify a steady-state model by setting c to None

        parameters
        ----------
        gr : mfgrid.Grid object
            contains the computation finite difference network.
        k : tuple of (kr, kz) or (kx, ky, kz)
            ky is ignored if gr.axial is True.
        ss : ndarray of gr.shape
            Specific storage coefficients.
        c:  np.ndarray of shape (gr.nlay - 1, gr.nrow, gr.ncol)
            The vertical resistance in between the model layers.
        idomain : ndarray of dtype int of size gr.shape
            Boundary array like in MODFLOW: 0 is inactive not zeros is active.
            Note that -1 for fixed hads (mf5) or flow through cells (mf6)
            are not used. Just zero or nog zero.

        returns
        -------
        self.out : dictionary
            the simulation results: Phi, Q, Qx, Qy, Qz, Qs
            ndarrays with time as first dimension.
        """
        if gr.axial:
            print('Axially symmetric model, y-values are ignored.')

        self.kx, self.ky, self.kz = gr.check_array_tuple(k)

        if c is not None:
            if isinstance(c, np.ndarray):
                if not np.all(c.shape == (gr.nlay -1, gr.ny, gr.nx)):
                    raise AssertionError(f"shape c ({c.shape}) should be {(gr.nlay - 1, gr.ny, gr.nx)}")
            self.c = c

        ss = ss[:, np.newaxis, np.newaxis] * gr.const(1.0)

        assert np.all(gr.shape == ss.shape), 'ss.shape != gr.shape'
        assert np.all(gr.shape == idomain.shape), 'idomain.shape != gr.shape'

        self.gr = gr
        self.ss = ss
        self.c = c
        self.idomain = idomain if isinstance(idomain, np.ndarray) else  gr.const(1, dtype=int)
        self.epsilon = epsilon

    @property
    def obsNames(self):
        """Return names of observation points."""
        return [p[0] for p in self.points]
    @property
    def r_ow(self):
        return [p[1] for p in self.points]
    @property
    def z_ow(self):
        return [p[2] for p in self.points]

    def simulate(self, t=None, hi=None, fh=None, fq=None, ghb=None, epsilon=0.67):
        """"Simulate the model with specified time and boundary conditions.

        You can run steady-state by setting self.ss to None.
        If there are more times, you can run multiple steady states with
        boundary conditions specified by fh, fq and ghb.
        If ss is not None, then the simulation will be transient.

        Parameters
        ----------
        t : time, numpy.ndarray
            if 0 is not included, it will be added to store
            the initial heads for t=0.
        hi : ndarray of gr.shape.
            initial heads and fixed heads.
        fh: dict of recarrays with dtype=dtypeH and keys are stress period numbers
            fixed head per modflow cell.
        fq : dict of ndarray of dtype=dtypeQ
            fixed infiltration per modflow cell. Extractions negative.
        ghb: np.recarray of dtype =dtypeGHB: [('I', int), ('h', float), ('C', float)]
            Specifies general head boundaries.
        epsilon : float between 0.5 and 1, default = 0.67
            Implicitness. Only plays a role in transient modeling.
            0.5 is indifferently stable (Crank Nicholson
            scheme of updating future head, most accurate), 1 is completely
            implicit, most stable, but sometimes a bit less accurate.e
            Modflow uses epsilon=1 implicitly.
        """
        self.epsilon = epsilon

        self.hi  = self.gr.const(0.) if hi is None else hi

        self.out = fdm3t(gr=self.gr, t=t,
            k=(self.kx, self.ky, self.kz), c=self.c,
            ss=self.ss, fh=fh, fq=fq, ghb=ghb, hi=self.hi,
            idomain=self.idomain, epsilon=self.epsilon)

        print('Model was run, see self.out')

        return self.out

    def show_time_curves(self, t=None, points=None, method='linear', **kwargs):
        '''Plot the time curves at given observation points.

        parameters
        ----------
        points: array of dtype=np.dtype([('name', str), ('x', float), ('y', float), (z, float)])
            names and position of each observation point.
        returns
        -------
            ax : Axis
        '''
        dtype = np.dtype([('name', str), ('x', float), ('y', float), ('z', float)])

        gr = self.gr

        assert isinstance(points, np.ndarray(dtype=dtype)), f"points must be an array with dtype={dtype}"
        assert np.all(np.close(gr.Z, gr.Z.mean(axis=(1, 2), keepdims=True))), "Layers must  be flat for interpolation."

        rgi = RegularGridInterpolator((gr.t, gr.xm, gr.ym, gr.zm), self.out['Phi'])

        figsize = kwargs.pop('figsize', None)
        if not figsize:
            figsize = kwargs.pop('size_inches', (12, 8))

        title  = kwargs.pop('title', 'title?')
        xlabel = kwargs.pop('xlabel', 'xlabel?')
        ylabel = kwargs.pop('ylabel', 'ylabel?')
        xscale = kwargs.pop('xscale', None)
        yscale = kwargs.pop('yscale', None)

        ax = kwargs.pop('ax', None)
        if ax is None:
            _, ax = plt.subplots(figsize=figsize)
            ax.set_title(title)
            ax.set_xlabel(xlabel)
            ax.set_ylabel(ylabel)
            ax.set_xscale(xscale)
            ax.set_yscale(yscale)
            ax.grid(True)

        # Numeric, fdm
        for (name, x, y, z) in points:
            phi_t = rgi((t, x, y, z), method=method)
            ax.plot(t, phi_t, label=f'{name}, x, y, z = ({x:>5.0g}, {y:>5.0g}, z={z:>5.0g}) m',
                     **kwargs)
        ax.legend(loc='best')
        return ax


    def get_psi_row(self, irow=0):
        '''Return the stream function psi and store in self.psi

        stores psi for all times in self.psi

        returns
        -------
            psi (values are in m2/d) for all times, irow  and all x[1:-1]
            use psi_x[idt] to get it for a given time step.
        '''
        # Qx(nt, nz, nr, nx-1) --> fix irow
        Qx_row = self.Qx[:, :, irow, :]
        self.psi_row = np.cumssum(np.concatenate((Qx_row[:, ::-1], np.zeros_like(Qx_row[:, 0])), axis=1))[:, ::-1]
        return self.psi_row

    def contour_row(self, dphi=None, dpsi=None, irow=0, idt=0, **kwargs):
        ''''Plot head and contours with streamlines in vertical cross section in given grid row.

        Notice that psi is only valid if the divergence in the row is negligible.

        parameters
        ----------
        dphi : float [m]
            head difference between successive contour lines.
        dpsi : float [m2/d]
            amount of water flowing between adjacent stream lines
        additional kwargs:
            passed on to contour fuctions
        '''
        patches = kwargs.pop('patches', None)

        title = kwargs.pop('title',
                   'Stijghoogten en stroomfunctie.')

        if dphi is not None:
            phi = self.out['Phi'][-1][:, 0, :]
            fmin = np.min(phi[np.logical_not(np.isnan(phi))])
            fmax = np.max(phi[np.logical_not(np.isnan(phi))])
            philevels = np.arange(np.floor(fmin), np.ceil(fmax), dphi)

            title += f' dphi={dphi:.3g}m.'

        if dpsi is not None:
            self.get_psi_row(irow=irow)[idt]
            pmin = np.min(self.psi)
            pmax = np.max(self.psi)
            psilevels = np.arange(np.floor(pmin), np.ceil(pmax), dpsi)

            title += f' dpsi={dpsi:.3g}m2/d'

        fig, ax = plt.subplots(figsize=kwargs.pop('size_inches', None))

        ax.set_title(title)
        ax.set_xlabel('r [m]')
        ax.set_ylabel('z [m]')

        ax.set_xlim(kwargs.pop('xlim',   None))
        ax.set_ylim(kwargs.pop('ylim',   None))
        ax.set_xscale(kwargs.pop('xscale', None))
        ax.set_yscale(kwargs.pop('yscale', None))

        ax.grid()

        if dphi is not None:
            ax.contour(self.gr.xm,     self.gr.zc, phi, philevels, **kwargs)
        if dpsi is not None:
            ax.contour(self.gr.x[1:-1], self.gr.z, self.psi, psilevels,
                       linestyles='-', colors='b')
        if patches is not None:
            for p in patches:
                ax.add_patch(p)
        return ax


def deGlee(r=None, D=None, kr=None, kz=None, c=None, use_ghb=False, **kw):
    """Return De Glee output in a two-layer axially symmetric layer.

    Steady state is computed be setting all ss = 0.  if c is given ghb is used else, kz is use
    to set the resistance.

    Returns the besselfunction because Q = 2 * np.kD

    Parameters
    ----------
    gr: mfgrid.Grid object
        the grid
    kr, kz: float, 3D arrays of horizontal and vertical conductivities
        kr, kz conductivities
    """
    kD = (kr * D).sum()
    ctop = c
    L = np.sqrt(kD * c)
    Q = 2 * np.pi * kD

    z = -np.cumsum(np.hstack((0, D)))

    gr = Grid(r, [-0.5, 0.5], z, axial=True)

    kr = kr[:, np.newaxis, np.newaxis] * gr.const(1.)
    kz = kz[:, np.newaxis, np.newaxis] * gr.const(1.)

    fq = np.zeros(1, dtype=dtypeQ)
    fq['I'], fq['q'] = gr.NOD[-1, 0, 0], Q
    fq = {0: fq}

    if use_ghb:
        # use ghb instead of c. So fh must be None as well as c
        ghb = np.zeros(gr.nx * gr.ny, dtype=dtypeGHB)
        ghb['I'], ghb['C'], ghb['h'] = gr.NOD[-1].ravel(), gr.Area.ravel() / c, 0.
        ghb = {0: ghb}
        fh = None
        c = None
    else:
        #use c insteand of ghb, so ghb must be None and fh and c must be set to None
        fh = np.zeros(gr.nx * gr.ny, dtype=dtypeH)
        fh['I'], fh['h'] = gr.NOD[0].ravel(), 0.
        fh = {0: fh}
        c = gr.const(0.)[:-1]
        c[0] = ctop
        ghb = None

    idomain = gr.const(1, dtype=int)
    hi = gr.const(0.)

    out = fdm3t(gr=gr, t=None, k=(kr, kr, kz), c=c,
                fh=fh, fq=fq, ghb=ghb,
                hi=hi, idomain=idomain)

    ax = newfig('De Glee example',
        'r [m]', 'drawdown',
        xscale='log', yscale='linear')
    ax.invert_yaxis()

    ax.plot(gr.xm, out['Phi'][-1, -1, 0, :], '.-', label='numerical')

    ax.plot(gr.xm, Q / (2 * np.pi * kD) * k0(gr.xm / L), '-', label='DeGlee')

    ax.legend()
    return ax

def theis1(um1=None, r=None, D=None, kr=None, kz=None, ss=None, r_=None, epsilon=0.67, **kw):
    """Return Theis output in a one-layer axially symmetric model.

    If np.all(ss == 0.), steady state should be returned. For his at least
    one cell must be fixed head (as specified by fh).
    """

    kD = (kr * D).sum()
    S  = (ss * D).sum()

    z = -np.cumsum(np.hstack((0, D)))
    gr = Grid(r, [-0.5, 0.5], z, axial=True)
    idomain = gr.const(1, dtype=int)

    Q = 4 * np.pi * kD

    ir = np.arange(gr.nx + 1)[r < 60][-1]
    t = um1 * r[ir] ** 2 * S / (4 * kD)

    hi = gr.const(0.)
    hi[0, 0, :] = Q / (4 * np.pi * kD) * exp1(gr.xm ** 2 * D  / (4 * kD * t[0]))

    fq = np.zeros(1, dtype=dtypeQ)
    fq['I'], fq['q'] = gr.NOD[-1, 0, 0], Q
    fq = {0: fq}


    fh = np.zeros(gr.nz * gr.ny, dtype=dtypeH)
    fh['I'], fh['h'] = gr.NOD[:, :, -1].ravel(), 0
    fh = {0: fh}
    fh = None

    out = fdm3t(gr=gr, t=t, k=(kr, kr, kz), ss=ss, fh=fh, fq=fq, hi=hi, idomain=idomain, epsilon=epsilon)

    xlim = np.logspace(-2, 6, 2)
    ylim = np.logspace(-4, 1, 2)

    ax = newfig(kw['title'],
        'r increases <---- (4 kD / S) t / r^2 [-] ----> time increase' ,
        's / (Q / (4 pi kD)) [-]',
        xscale='log', yscale='log',
        xlim=xlim, ylim=ylim)

    cc = color_cycler()
    # select a few distances for which the show the graph
    for ir in range(0, gr.nx, 10):
        color = next(cc)
        rm = gr.xm[ir]
        if rm < 1.0 or rm > 1000.:
            continue
        ax.plot((4 * kD  / S) * (t / rm ** 2), out['Phi'][:, -1, 0, ir] / (Q / (4 * np.pi * kD)), '-', color=color, label=f'r={gr.xm[ir]:.3g} m')

    ax.plot(um1, exp1(1 / um1), '.', label=f'Theis, r={gr.xm[ir]:.3g} m')
    ax.legend()
    return ax

def theis_use_class(um1=None, r=None, D=None, kr=None, kz=None, ss=None, r_=None, epsilon=0.67, **kw):
    """Return Theis output in a one-layer axially symmetric model, but use class Fdm3t instead of function fdm3t.

    If np.all(ss == 0.), steady state should be returned. For his at least
    one cell must be fixed head (as specified by fh).
    """

    kD = (kr * D).sum()
    S  = (ss * D).sum()

    z = -np.cumsum(np.hstack((0, D)))
    gr = Grid(r, [-0.5, 0.5], z, axial=True)
    idomain = gr.const(1, dtype=int)

    mdl = Fdm3t(gr=gr, k= (kr, kr, kz), c=None, ss=ss, idomain=idomain)

    Q = 4 * np.pi * kD

    ir = np.arange(gr.nx + 1)[r < 60][-1]
    t = um1 * r[ir] ** 2 * S / (4 * kD)

    hi = gr.const(0.)
    hi[0, 0, :] = Q / (4 * np.pi * kD) * exp1(gr.xm ** 2 * D  / (4 * kD * t[0]))

    fq = np.zeros(1, dtype=dtypeQ)
    fq['I'], fq['q'] = gr.NOD[-1, 0, 0], Q
    fq = {0: fq}


    fh = np.zeros(gr.nz * gr.ny, dtype=dtypeH)
    fh['I'], fh['h'] = gr.NOD[:, :, -1].ravel(), 0
    fh = {0: fh}
    fh = None

    out = mdl.simulate(t=t, fh=fh, fq=fq, hi=hi, epsilon=epsilon)

    xlim = np.logspace(-2, 6, 2)
    ylim = np.logspace(-4, 1, 2)

    ax = newfig(kw['title'],
        'r increases <---- (4 kD / S) t / r^2 [-] ----> time increase' ,
        's / (Q / (4 pi kD)) [-]',
        xscale='log', yscale='log',
        xlim=xlim, ylim=ylim)

    cc = color_cycler()
    # select a few distances for which the show the graph
    for ir in range(0, gr.nx, 10):
        color = next(cc)
        rm = gr.xm[ir]
        if rm < 1.0 or rm > 1000.:
            continue
        ax.plot((4 * kD  / S) * (t / rm ** 2), out['Phi'][:, -1, 0, ir] / (Q / (4 * np.pi * kD)), '-', color=color, label=f'r={gr.xm[ir]:.3g} m')

    ax.plot(um1, exp1(1 / um1), '.', label=f'Theis, r={gr.xm[ir]:.3g} m')
    ax.legend()
    return ax


def hantush(um1=None, r=None, kr=None, kz=None, D=None, ss=None, rhos=None, use_ghb=False, epsilon=0.67, **kw):
    """Show hantush well function using two layer model."""

    # c is not used, it's obtained for the given rho = r / lambda

    kD = (kr * D).sum()
    S  = (ss * D).sum()
    Q = 4 * np.pi * kD

    z =- np.hstack((0, D)).cumsum()

    gr = Grid(r, [-0.5, 0.5], z, axial=True)

    if gr.nlay == 1:
        use_ghb = True

    idomain = gr.const(1, dtype=int)
    hi = gr.const(0.)
    kx = kr[:, np.newaxis, np.newaxis] * gr.const(1)
    kz = kz[:, np.newaxis, np.newaxis] * gr.const(1.)
    ss = ss[:, np.newaxis, np.newaxis] * gr.const(1.)

    fq = np.zeros(1, dtype=dtypeQ)
    fq['I'], fq['q'] = gr.NOD[-1, 0, 0], Q
    fq = {0: fq}

    xlim = np.logspace(-2, 6, 2)
    ylim = np.logspace(-4, 1, 2)

    ax = newfig(f"Hantush using {gr.nlay} layer(s), leakage using {'ghb' if use_ghb else 'c'}, epsilon={epsilon}",
            r'increasing r <--- $(4 kD /S) (t / r^2)$ ---> increasing t',
            r'$s / (Q / (4 \pi kD))$',
            xscale='log', yscale='log', xlim=xlim, ylim=ylim)

    ir = np.arange(gr.nx + 1)[r < 60][-1]

    for rho in rhos:
        t = r[ir] ** 2 * S / (4 * kD) * um1
        L = r[ir] / rho
        ctop = L ** 2  / kD

        if use_ghb:
            ghb = np.zeros(gr.nx * gr.ny, dtype=dtypeGHB)
            ghb['I'], ghb['h'], ghb['C'] = gr.NOD[-1].ravel(), 0., gr.Area.ravel() / ctop
            ghb = {0: ghb}
            c = None
            fh = None
        else:
            fh = np.zeros(gr.nx * gr.ny, dtype=dtypeH)
            fh['I'], fh['h'] = gr.NOD[0].ravel(), 0.
            fh = {0: fh}
            c = gr.const(0.)[:-1]
            c[0] = ctop
            ghb = None

        out = fdm3t(gr=gr, t=t, k=(kx, kx, kz), ss=ss, c=c, fh=fh, fq=fq, ghb=ghb, hi=hi, idomain=idomain, epsilon=epsilon)

        um1 = 4 * kD * t  / (S * r[ir] ** 2)
        wh = out['Phi'][:, -1, 0, ir] /(Q  / (4 *np.pi * kD))

        ax.plot(um1, wh, '-',                 label=f"numeric fdm, rho={rho:.4g}")
        ax.plot(um1, Wh(1/um1, rho)[0], '--', label=f'Wh(u, rho),  rho={rho:.4g}')

    ax.legend()    
    return ax

def boulton(um1=None, r=None, D=None, kr=None, kz=None, ss=None, rhos=None, epsilon=0.67, **kw):

    kD = (kr[1:] * D[1:]).sum()
    S0  = ss[0] * D[0]
    S1 = (ss[1:] * D[1:]).sum()

    Q = 4 * np.pi * kD

    z = np.hstack((0, -D))

    gr = Grid(r, [-0.5, +0.5], z, axial=True)

    idomain = gr.const(1, dtype=int)

    ss = ss[:, np.newaxis, np.newaxis] * gr.const(1.)
    kr = kr[:, np.newaxis, np.newaxis] * gr.const(1.)
    kz = kz[:, np.newaxis, np.newaxis] * gr.const(1.)

    hi = gr.const(0.)

    fq = np.zeros(1, dtype=dtypeQ)
    fq['I'], fq['q'] = gr.NOD[-1, 0, 0], Q
    fq = {0: fq}

    xlim = np.logspace(-2, 7, 2)
    ylim = np.logspace(-4, 2, 2)

    ax = newfig(kw['title'] + f", no fixed heads, grid shape = {gr.shape}, ",
            r'increasing r <--- $(4 kD /S) (t / r^2)$ ---> increasing t',
            r'$s  / (Q / (4 \pi kD))$',
            xscale='log', yscale='log', xlim=xlim, ylim=ylim)

    ax.plot(um1,          exp1(1/um1), 'r.-',  lw=2, label=f'Theis Sy = {S0:.4g}')
    ax.plot(um1 * S0 /S1, exp1(1/um1), 'r.--', lw=2, label=f'Theis S  = {S1:.4g}')

    ir = np.arange(gr.nx + 1)[r < 60][-1]

    clrs = color_cycler()
    for rho in rhos:
        clr = next(clrs)
        t = r[ir] ** 2 * S1 / (4 * kD) * um1
        B = r[ir] / rho
        ctop = B ** 2  / kD

        c = gr.const(0.)[:-1]
        c[0] = ctop

        out = fdm3t(gr=gr, t=t, k=(kr, kr, kz), ss=ss, fh=None,
                    fq=fq, hi=hi, idomain=idomain, c=c, ghb=None, epsilon=epsilon)

        ax.plot(um1, out['Phi'][:, -1, 0, ir],  color=clr, label=f"Phi[:,-1,0,{ir}], rho={rho:.4g}")
        ax.plot(um1, Wh(1/um1, rho)[0], '--', color=clr, label=f"Wh(u, rho),     rho={rho:.4g}")

    ax.legend()
    return ax

def brug223_02(t=None, r=None, D=None, kr=None, kz=None, ss=None, epsilon=0.67, **kw):
    """Return solution of Bruggeman 223_02, in a one-layer axially symmetric model.

    The problem is flow  outside a cyling with radius R afger sudden head change at R.
    """
    kD = (kr * D).sum()
    S  = (ss * D).sum()

    z = -np.cumsum(np.hstack((0, D)))
    gr = Grid(r, [-0.5, 0.5], z, axial=True)

    kr = kr[:, np.newaxis, np.newaxis] * gr.const(1.)
    kz = kz[:, np.newaxis, np.newaxis] * gr.const(1.)
    ss = ss[:, np.newaxis, np.newaxis] * gr.const(1.)

    idomain = gr.const(1, dtype=int)

    s0 = 1.0
    hi = gr.const(0.)
    #hi[:, :, 0] = s0


    fh = np.zeros(gr.nz * gr.ny, dtype=dtypeH)
    fh['I'], fh['h'] = gr.NOD[:, :, 0].ravel(), s0
    fh = {0: fh}

    out = fdm3t(gr=gr, t=t, k=(kr, kr, kz), ss=ss, fh=fh, fq=None, hi=hi, idomain=idomain, epsilon=epsilon)

    xlim = np.logspace(np.log10(t[0]), np.log10(t[-1]), 2)
    ylim = np.logspace(-4, 1, 2)

    # The head change s
    ax = newfig(kw['title'],
        't [d]',
        's [m]',
        xscale='log', yscale='log',
        xlim=xlim, ylim=ylim)

    cc = color_cycler()
    # select a few distances for which the show the graph
    for ir in np.hstack((0, 1, 2, 3, 4, np.arange(5, gr.nx, 5))):
        if gr.xm[ir] > 100:
            continue
        color = next(cc)
        ax.plot(t, out['Phi'][:, -1, 0, ir], '-', color=color, label=f'r={gr.xm[ir]:.3g} m')

    ax.legend()

    # The flow Q
    ylim = np.logspace(0, 5, 2)

    ax = newfig(kw['title'] + "Flow Q [m3/d]",
        't [d]',
        'Q [m3/d]',
        xscale='log', yscale='log',
        xlim=xlim, ylim=ylim)

    cc = color_cycler()
    # select a few distances for which the show the graph
    for ir in np.hstack((0, 1, 2, 3, 4, np.arange(5, gr.nx, 5))):
        if gr.xm[ir] > 1000:
            continue
        color = next(cc)
        ax.plot(t[1:], out['Qx'][:, -1, 0, ir], '-', color=color, label=f'r={gr.x[ir]:.3g} m')
    ax.legend()
    return ax

def kraaij(t=None, x=None, D=None, kx=None, kz=None, ss=None, dh=None, epsilon=1.0, **kw):
    """Return Kraaijenhoff vd Leur output in a one-layer model.

    If np.all(ss == 0.), steady state should be returned. For his at least
    one cell must be fixed head (as specified by fh).
    """

    def kraaijenhoff(kD=None, S=None, t=None, x=None, dh=None):
        """Return Kraaijenhoff vd Leur solution."""
        if np.isscalar(t):
            t = np.array(t) .reshape(1, 1)

        b = x[-1]
        t = t[:, np.newaxis]
        xm = 0.5 * (x[:-1] + x[1:])
        xm = xm[np.newaxis, :]

        s = np.zeros((t.shape[0], xm.shape[-1]))
        for j in range(1, 20):
            _2jm1 = 2 * j - 1
            T = b ** 2 * S / kD
            s +=  (-1) ** (j - 1) / _2jm1 * np.cos(_2jm1 * np.pi / 2 * xm / b) * np.exp(-(_2jm1 * np.pi / 2) ** 2 * t /T)
        return dh * 4  / np.pi * s

    x = np.hstack((0., x[x > 0]))
    kD = (kx * D).sum()
    S  = (ss * D).sum()

    T = x[-1] ** 2 * S / kD * (2 / np.pi) ** 2
    tkrvdl = np.arange(1, 11) * T
    t = np.unique(np.hstack((t, tkrvdl)))

    z = -np.cumsum(np.hstack((0, D)))
    gr = Grid(x, [-0.5, 0.5], z, axial=False)

    krvdl = kraaijenhoff(kD=kD, S=S, t=tkrvdl, x=x, dh=dh)

    idomain = gr.const(1, dtype=int)
    hi = gr.const(dh)

    fh = np.zeros(gr.nz * gr.ny, dtype=dtypeH)
    fh['I'], fh['h'] = gr.NOD[:, :, -1].ravel(), 0.
    fh = {0: fh}

    out = fdm3t(gr=gr, t=t, k=(kx, kx, kz), ss=ss, fh=fh, fq=None, hi=hi, idomain=idomain, epsilon=epsilon)

    ax = newfig(kw['title'],
        'x [m]',
        'h - h0 [m]')

    cc = color_cycler()
    for it, t_ in enumerate(t):
        if t_ not in tkrvdl:
            continue
        color = next(cc)
        ax.plot(gr.xm, out['Phi'][it, -1, 0, :], '-', color=color, label=f't={t_:.4g} d')
    cc = color_cycler()
    for it, t_ in enumerate(tkrvdl):
        color = next(cc)
        ax.plot(gr.xm, krvdl[it, :], '.', color=color, label=f'krvl, t={t_:.4g} d')
    ax.legend()
    return ax

cases = {
    'steady':
        {'title': 'steady',
         "comment": """This test is to verify the accuracy of the model against an analytical
         solution of Theis or even Hantush by a regular simulation, no dimensionless parameters.
         """,
        't': np.logspace(-4, 9, 131),
        'r': np.hstack((0, np.logspace(-2, 6, 81))),
        'D': np.array([  10., 50.]),
        'kr': np.array([ 1e-6, 10.]),
        'kz': np.array([ 1e6,  1e6]),
        'Ss': np.array([ 0.01, 0.2e-6]),
        'c': np.array([600.]),
        'use_ghb': True,
         },
    'Theis':
        {'title': r"""Theis numeric vs um1 = 1/u. Increasing um1 --> increasing time --> decreasing r.
         Curves for different r overlap due to the choice of both axes which yieldds the Theis type curve.
         Small deviations with the analytic type curve occur only for very large r or very small t.
         """,
         'comment': """Theis numeric.
         Computes the theis type curve by plotting s / (Q / (4 pi kD) vs 4 kD / S * t / r^2
         and compare this with the real theis function exp1.
         """,
        'um1': np.logspace(-5, 9, 141), # um1 = 1/ u
        'r': np.hstack((0., np.logspace(-2, 6, 381))),
        'D': np.array([50.]),
        'kr': np.array([10.]),
        'kz': np.array([1e6]),
        'ss': np.array([1e-5]),
        'epsilon': 0.5,
        },
    'Hantush1L':
        {'title' : 'Hantush using 1 layer',
        'comment': """Hantush is numerically simlated using a single model layer, the inflow
        at the top is made using general head boundaries. This result should be the same
        as the one alled Hantush 2L. It's a way to verify that the GHB has been implemented correctly.
        """,
        #'um1': np.logspace(-3, 3, 71), # um1 = 1/ u,
        'um1': np.logspace(-3, 3, 31), # um1 = 1/ u,
        'r': np.hstack((0., np.logspace(-2, 6, 1 * 80 + 1))), # so many points per log cycle
        'D': np.array([50.]),
        'kr': np.array([10.]),
        'kz': np.array([1e6]),
        'ss': np.array([0.2e-6]),
        'rhos': [0., 0.01, 0.03, .1, .3, 1., 3.],
        'r_': 30.,
        'epsilon': 1.0,
        },
    'Hantush2L': {
        'title': 'Hantush using 2 layers',
        'comment': """Hantush is simulated using 2 layer. One is the top layer with fixed head and
        given resistance between the first and second layer. The second layer is the aquifer. This
        example also serves to verify the implementation of the interlayer resistance 'c'.
        """,
        'um1': np.logspace(-5, 9, 141), # um1 = 1/ u
        'r': np.hstack((0., np.logspace(-2, 6, 581))),
        'D': np.array([10., 20.]),
        'kr': np.array([ 1e-6, 1e1]),
        'kz': np.array([ 1e6,  1e6]),
        'ss': np.array([   0., 1e-5]),
        'rhos': [0., 0.01, 0.03, .1, .3, 1., 3.],
        'r_': 30.,
        'use_ghb': False,
        'epsilon': 0.5,
        },
    'Boulton63': {
        'title': 'Boulton 1963, delayed yield',
        'comment': """Boulton is simulated using 2 layers. One is the top layer with given Sy and
        given resistance between the first and second layer. The second layer is the aquifer with
        elastic storage coefficient S. The resisance between the two layers follows from the
        value of rho used. A single reference distance r_ is used for all curve. This has no effect
        on the results because these are given on dimensionless graphs.
        """,
        'um1': np.logspace(-5, 9, 141), # um1 = 1/ u
        'r': np.hstack((0., np.logspace(-2, 6, 8 * 80))),
        'D': np.array([10., 50.]),
        'kr': np.array([ 0., 10.]),
        'kz': np.array([ 1e6,  1e6]),
        'ss': np.array([  0.01, 0.2e-6]),
        'rhos': [0., 0.01, 0.03, .1, .3, 1., 3.], # c comes from rho
        'r_': 30,
        'epsilon': 0.5,
        },
    'Brug223_02': {
        'title': "Bruggeman (1999) solution 223.02.""",
         'comment': """Sudden change of head at r=R.
         This solution is very difficult to correctly evaluate analytically.
         Same as Theis but sudden head change at cylinder with r=R.""",
        't': np.logspace(-3, 3, 141), # um1 = 1/ u
        'r': np.hstack((30. - 0.01, np.logspace(np.log10(30.), 6, 1 * 160))),
        'D': np.array([100.]),
        'kr': np.array([10.]),
        'kz': np.array([1e6]),
        'ss': np.array([1e-3]),
        'epsilon': 0.6,
        },
    'Kraaij':
        {'title': r"""Kraaijenhoff vd Leur, 1D head development after sudden change of head at x +/- b.
         """,
         'comment': """Kraaij.
         Computes the head change in a cross section after chaning the head at +/-b suddenly at t=0
         """,
        't': np.logspace(-3, 3, 61),
        'x': np.linspace(0, 1000.0, 2 * 100),
        'D': np.array([50.]),
        'kx': np.array([10.]),
        'kz': np.array([1e6]),
        'ss': np.array([1e-3]),
        'dh': 1.0,
        'epsilon': 0.5
        },
    }

if __name__ == '__main__':

    print(f'Available cases:\n{cases.keys()}')
    deGlee(**cases['steady'])
    theis1(**cases['Theis'])
    theis_use_class(**cases['Theis'])
    hantush(**cases['Hantush1L']) # for S=0 -> steady De Glee
    hantush(**cases['Hantush2L'])
    boulton(**cases['Boulton63'])
    brug223_02(**cases['Brug223_02'])
    kraaij(**cases['Kraaij'])

    plt.show()
