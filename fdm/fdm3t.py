''''A finite difference model for ransient groundwater flow is implemented.
The implementation is in the function fdm3t. Some other modules are used
that are in subdirectories of the tools folder. One may change the line that
includes the tools folde to an absolute path on a specific computer.

The model has also been wrapped in thte class Fdm3t.

Under __main__ are several tests that have been implemented as functions
themselves to prevent clutter under __main__.

The data for the different tests are collectd in a dictionary 'cases'.
'''
import os
import sys
sys.path.insert(0, os.path.abspath('../')) # Start in the subdirectory of tools

import warnings
import numpy as np
import matplotlib.pyplot as plt
import scipy.sparse as sp
from scipy.special import exp1, k0
from scipy.interpolate import interp1d, RegularGridInterpolator
from scipy.sparse.linalg import spsolve # to use its short name
from matplotlib import colors
from analytic.hantush_conv import Wh
from etc import newfig, color_cycler

from fdm.mfgrid import Grid

class InputError(Exception):
    pass

ghb_dtype = np.dtype([('I', int),('h', float),('C', float)])

def fdm3t(gr=None, t=None, kxyz=None, c=None, Ss=None, GHB=None,
          FQ=None, HI=None, IBOUND=None, epsilon=0.67):
    """Transient 3D Finite Difference Model returning computed heads and flows.

    Heads and flows are returned as 3D arrays as specified under output parmeters.
    
    Steady-state flow is computed when setting Ss = 0 for all Ss and making
    sure at least one cell is fixed head, i.e. one IBOUND value < 0.
    For steady state, also use epsilon = 1, to prevent oscillatioin in the results
    of the first times.

    Parameters
    ----------
    gr : `grid_object`, generated by gr = Grid(x, y, z, ..)
        if `gr.axial`==True, then the model is run in axially symmetric model
    t : ndarray, shape: [Nt+1]
        times at which the heads and flows are desired including the start time,
        which is usually zero, but can have any value.
    kxyz: 3-tuple of ndarray, shape: (Ny, Nx, Nz), [L/T]
        hydraulic conductivities along the three axes, 3D arrays.
    c: nd.array of shape (Nz-1, Ny, Nx) or (Nz, Nx, Ny) or (Nz+1, Ny, Nx)
        vertical resistances between the layers
            - between the layers if shape(0) == nlay - 1
            - includes above top layer if shape(0) = nlay
            - includes both  top and bottom layers if shape(0) = nlay + 1
        may be None
    Ss : ndarray, shape: (Ny, Nx, Nz), [L-1]
        specific elastic storage
    GHB: recarray with dtype = np.dtype([(I, 'int'), ('h', float), ('C', float)])
        General head boundaries recarray. I=index in flatten array, h, head and C conductance.
        TODO: Generalize this to include times.
    FQ : ndarray, shape: (Ny, Nx, Nz), [L3/T]
        prescrived cell flows (injection positive, zero of no inflow/outflow)
    IH : ndarray, shape: (Ny, Nx, Nz), [L]
        initial heads. `IH` has the prescribed heads for the cells with prescribed head.
    IBOUND : ndarray, shape: (Ny, Nx, Nz) of int
        boundary array like in MODFLOW with values denoting
        * IBOUND>0  the head in the corresponding cells will be computed
        * IBOUND=0  cells are inactive, will be given value NaN
        * IBOUND<0  coresponding cells have prescribed head
    epsilon : float, dimension [-]
        degree of implicitness, choose value between 0.5 and 1.0

    outputs
    -------
    out : dictionary gr, time, heads and flows:
        out['gr]: mfgrid.Grid objecy (holding the network)
        out['t']: array of times including the time of the initial head.
        out['Phi'] : ndarray, shape: (Nt+1, Ny, Nx, Nz), [L3/T]
            computed heads. Inactive cells will have NaNs
            To get heads at time t[i], use Out.Phi[i]
            Out.Phi[0] = initial heads
        out['Q']   : ndarray, shape: (Nt, Ny, Nx, Nz), [L3/T]
            net inflow in all cells during time step, inactive cells have 0
            Q during time step i, use Out.Q[i]
        out['Qs']  : ndarray, shape: (Nt, Ny, Nx, Nz), [L3/T]
            release from storage during time step.
        out['Qx']   : ndarray, shape: (Nt, Ny, Nx-1, Nz), [L3/T]
            intercell flows in x-direction (parallel to the rows)
        out['Qy']  : ndarray, shape: (Nt, Ny-1, Nx, Nz), [L3/T]
            intercell flows in y-direction (parallel to the columns)
        out['Qz']  : ndarray, shape: (Nt, Ny, Nx, Nz-1), [L3/T]
            intercell flows in z-direction (vertially upward postitive)
        out['GHB'] : ndarray of gr.shape of general head boundary inflows if GHB is not None.

    TO 161024, 230418
    """
    if gr.axial:
        print('Running in axial mode, y-values are ignored.')

    if isinstance(kxyz, (tuple, list)):
        kx, ky, kz = kxyz
    else:
        kx = ky = kz = kxyz
        
    if c is not None:
        if isinstance(c, np.ndarray):
            if not np.all(c.shape == (gr.nlay -1, gr.ny, gr.nx)):
                raise AssertionError("shape c ({0}) should be {1}".
                                 format(c.shape, (gr.nlay, gr.ny, gr.nx)))

    if kx.shape != gr.shape:
        raise AssertionError("shape of kx {0} differs from that of model {1}".format(kx.shape,gr.shape))
    if ky.shape != gr.shape:
        raise AssertionError("shape of ky {0} differs from that of model {1}".format(ky.shape,gr.shape))
    if kz.shape != gr.shape:
        raise AssertionError("shape of kz {0} differs from that of model {1}".format(kz.shape,gr.shape))
    if Ss.shape != gr.shape:
        raise AssertionError("shape of Ss {0} differs from that of model {1}".format(Ss.shape,gr.shape))

    kx[kx<1e-20] = 1e-50 # Why?
    ky[ky<1e-20] = 1e-50
    kz[kz<1e-20] = 1e-50
    
    active = (IBOUND >0).reshape(gr.nod,)  # boolean vector denoting the active cells
    inact  = (IBOUND==0).reshape(gr.nod,)  # boolean vector denoting inacive cells
    fxhd   = (IBOUND <0).reshape(gr.nod,)  # boolean vector denoting fixed-head cells
    
    if np.all(Ss == 0.):
        if all(fxhd == False) and GHB is None:
            raise ValueError('If all Ss == 0, there must be at least one fxhd cell, i.e. one IBOUND value must be -1 or GHB must be used.')
        else:
            epsilon = 1.0 # Prevents oscillations in early times
    
    # reshaping shorthands
    dx = np.reshape(gr.dx, (1, 1, gr.nx))
    dy = np.reshape(gr.dy, (1, gr.ny, 1))

    # half cell flow resistances
    if not gr.axial:
        RxE = 0.5 *    dx / (   dy * gr.DZ) / kx
        RxW = RxE
        Ry1 = 0.5 *    dy / (gr.DZ *    dx) / ky
        Rz1 = 0.5 * gr.DZ / (   dx *    dy) / kz        
        Rc  = 0 if c is None else c   / (dx * dy)
    else:
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", category=RuntimeWarning) # Division  by zero when x==0, is ok --> np.inf as resistance.
            RxW = 1 / (2 * np.pi * kx * gr.DZ) * np.log(gr.xm / gr.x[:-1]).reshape((1, 1, gr.nx))
            RxE = 1 / (2 * np.pi * kx * gr.DZ) * np.log(gr.x[1:] /  gr.xm).reshape((1, 1, gr.nx))
        Ry1 = np.inf * np.ones(gr.shape)
        Rz1 = 0.5 * gr.DZ / (np.pi * (gr.x[1:] ** 2 - gr.x[:-1] ** 2).reshape((1, 1, gr.nx)) * kz)
        Rc  = 0 if c is None else c   / (np.pi * (gr.x[1:] ** 2 - gr.x[:-1] ** 2).reshape((1, 1, gr.nx)))

    # set flow resistance in inactive cells to infinite
    RxE[inact.reshape(gr.shape)] = np.inf
    RxW[inact.reshape(gr.shape)] = np.inf
    Ry1[inact.reshape(gr.shape)] = np.inf
    Ry2 = Ry1
    Rz1[inact.reshape(gr.shape)] = np.inf
    Rz2 = Rz1

    # conductances between adjacent cells
    Cx = 1 / (RxW[: , :,1:] + RxE[:  ,:  ,:-1])
    Cy = 1 / (Ry1[: ,1:, :] + Ry2[:  ,:-1,:  ])
    Cz = 1 / (Rz1[1:, :, :] + Rc + Rz2[:-1,:  ,:  ])
        
    # storage term, variable dt not included
    Cs = Ss * gr.DZ * gr.Area[np.newaxis, :, :, ] / epsilon
    
    # cell number of neighboring cells
    IW = gr.NOD[:,:,:-1]  # east neighbor cell numbers
    IE = gr.NOD[:,:, 1:] # west neighbor cell numbers
    IN = gr.NOD[:,:-1,:] # north neighbor cell numbers
    IS = gr.NOD[:, 1:,:]  # south neighbor cell numbers
    IT = gr.NOD[:-1,:,:] # top neighbor cell numbers
    IB = gr.NOD[ 1:,:,:]  # bottom neighbor cell numbers

    R = lambda x : x.ravel()  # generate anonymous function R(x) as shorthand for x.ravel()

    # notice the call  csc_matrix( (data, (rowind, coind) ), (M,N))  tuple within tupple
    # also notice that Cij = negative but that Cii will be postive, namely -sum(Cij)
    A = sp.csc_matrix(( np.concatenate(( R(Cx), R(Cx), R(Cy), R(Cy), R(Cz), R(Cz)) ),\
                        (np.concatenate(( R(IE), R(IW), R(IN), R(IS), R(IT), R(IB)) ),\
                         np.concatenate(( R(IW), R(IE), R(IS), R(IN), R(IB), R(IT)) ),\
                      )),(gr.nod,gr.nod))

    A = -A + sp.diags( np.array(A.sum(axis=1)).ravel() ) # Change sign and add diagonal

    #Initialize output arrays (= memory allocation)
    Nt = len(t)-1
    Phi = np.zeros((Nt+1, gr.nod)) # Nt+1 times
    Q   = np.zeros((Nt  , gr.nod)) # Nt time steps
    Qs  = np.zeros((Nt  , gr.nod))
    Qx  = np.zeros((Nt, gr.nz, gr.ny, gr.nx-1))
    Qy  = np.zeros((Nt, gr.nz, gr.ny-1, gr.nx))
    Qz  = np.zeros((Nt, gr.nz-1, gr.ny, gr.nx))

    # reshape input arrays to vectors for use in system equation
    FQ = R(FQ);  HI = R(HI);  Cs = R(Cs)
    
    if GHB is not None:
        assert GHB.dtype == np.dtype([('I', int), ('h', float), ('C', float)])
        assert np.all(np.logical_and(GHB['I'] >= 0, GHB['I'] < gr.nod)),\
            "All global indices must be 0 <= I < gr.nod = {} !".format(gr.nod)
        Cghb = gr.const(0.)
        Hghb = gr.const(0.1)
        Cghb.ravel()[GHB['I']] = GHB['C']
        Hghb.ravel()[GHB['I']] = GHB['h']
        Qghb = np.zeros((Nt, gr.nod))
        
    # initialize heads
    Phi[0] = HI

    # solve heads at active locations at t_i+eps*dt_i

    Nt=len(t)  # for heads, at all times Phi at t[0] = initial head
    Ndt=len(np.diff(t)) # for flows, average within time step

    for idt, dt in enumerate(np.diff(t)):

        it = idt+1

        RHS = FQ - (A + sp.diags(Cs / dt))[:,fxhd].dot(Phi[it-1][fxhd]) # Right-hand side vector
        if GHB is None:  
            Phi[it][active] = spsolve( (A + sp.diags(Cs / dt))[active][:,active],
                RHS[active] + Cs[active] / dt * Phi[it-1][active])
        else:
            Phi[it][active] = spsolve( (A + sp.diags(Cghb.ravel()) + sp.diags(Cs / dt))[active][:,active],
                RHS[active] + R(Cghb * Hghb)[active] + Cs[active] / dt * Phi[it-1][active])

        # net cell inflow
        Q[idt]  = A.dot(Phi[it])

        Qs[idt] = -Cs/dt * (Phi[it]-Phi[it-1])

        #Flows across cell faces
        Qx[idt] =  -np.diff( Phi[it].reshape(gr.shape), axis=2) * Cx
        Qy[idt] =  +np.diff( Phi[it].reshape(gr.shape), axis=1) * Cy
        Qz[idt] =  +np.diff( Phi[it].reshape(gr.shape), axis=0) * Cz
        if GHB is not None:
            Qghb[idt] = (Hghb.ravel() - Phi[it]) * Cghb.ravel()

        # update head to end of time step
        Phi[it][active] = Phi[it-1][active] + (Phi[it]-Phi[it-1])[active]/epsilon
        Phi[it][fxhd]   = Phi[it-1][fxhd]
        Phi[it][inact]  = np.nan

    # reshape Phi to shape of grid
    Phi = Phi.reshape(  (Nt, ) + gr.shape)
    Q   = Q.reshape(    (Ndt,) + gr.shape)
    Qs  = Qs.reshape(   (Ndt,) + gr.shape) 

    out = dict()
    out.update(gr=gr, t=t, Phi=Phi, Q=Q, Qs=Qs, Qx=Qx, Qy=Qy, Qz=Qz)
    
    if GHB is not None:
        Qghb = Qghb.reshape((Ndt,) + gr.shape)
        out.update(Qghb=Qghb)
    
    return out 

class Fdm3t:
    """Class of trainsient finite difference groundwater model.
    
    Wraps the function fdm3t in it.    
    """

    def __init__(self, gr=None, t=None, kxyz=None, Ss=None, FQ=None, HI=None,
                 c=None, GHB=None, IBOUND=None, epsilon=1.0):
        """Instantiate a 3D transient axially symmetric groundwater
        finite difference model.

        All model arrays must have shape [nlay, nrow, ncol]. This is so
        even if an axially symmetric model has only one row.

        parameters
        ----------
        gr : mfgrid.Grid object
            contains the computation finite difference network.
        t : time, numpy.ndarray
            if 0 is not included, it will be added to store
            the initial heads for t=0.
        kxyz : tuple of (Kr, Kz) or (Kr, Ky, Kz)
            Ky is ignored.
        Ss : ndarray of gr.shape
            Specifici storage coefficients.
        FQ : ndarray of gr.shape
            fixed infiltration per modflow cell. Extractoins are
            negative.
            This could be specified as a dict[isp] where isp is the
            stress-period number.
        HI : ndarray of gr.shape.
            initial heads and fixed heads.
            The heads are fixed where IBOUND<0.
            This could be specified as a dict[isp] where isp is the
            stress-period number. In that case, the heads at the
            nodes with IBOUND<0 will be replaced by the fixed heads
            speciied for the stress period.
        c: np.ndarray of shape (gr.nlay - 1, gr.nrow, gr.ncol)
            The vertical resistance in between the model layers.
        GHB: np.recarray of dtype =np.dtype([('I', int), ('h', float), ('C', float)])
            Specifies general head boundaries.
        IBOUND : ndarray of dtype int of size gr.shape
            Boundary array like in MODFLOW. <0 means head is
            prescribed for the cell; 0 means cell is inactive, >0 means,
            head will be compute for the cell.
        epsilon : float between 0.5 and 1.
            Implicitness. 0.5 is indifferently stable (Crank Nicholson
            scheme of updating future head, most accurate), 1 is completely
            implicit, most stable, but sometimes a bit less accurate.e
            Modflow uses epsilon=1 implicitly.
            
        returns
        -------
        self.out : dictionary
            the simulation results: Phi, Q, Qx, Qy, Qz, Qs
            ndarrays with time as first dimension.
        """
        if isinstance(kxyz, (tuple, list)):
            if len(kxyz)==3:
                Kh, _, Kv = kxyz
            elif len(kxyz) == 2:
                Kh, Kv = kxyz
            elif len(kxyz) == 1:
                Kh = kxyz[0]
                Kv = Kh
            else:
                raise ValueError("Can't understand input kxyz, use (Kx, Kz) tuple")
        else:
            Kh = kxyz
            Kv = kxyz

        assert np.all(gr.shape == Kh.shape), 'gr.shape != Kh.shape'
        assert np.all(gr.shape == Kv.shape), 'gr.shape != Kv.shape'
        assert np.all(gr.shape == FQ.shape), 'gr.shape != FQ.shape'
        assert np.all(gr.shape == Ss.shape), 'gr.shape != HI.shape'
        assert np.all(gr.shape == IBOUND.shape), 'gr.shape != IBOUND.shape'

        self.gr = gr
        self.t  = t
        self.Kh = Kh
        self.Kv = Kv
        self.c  = c
        self.Ss = Ss
        self.FQ = FQ
        self.HI = HI
        self.c = c
        self.GHB = GHB
        self.IBOUND = IBOUND

        # Immediately runs the model and stores its output
        self.out = fdm3t(gr=self.gr, t=self.t,
                         kxyz=(self.Kh, self.Kh, self.Kv),
                         Ss=self.Ss, FQ=self.FQ, HI=self.HI, c=self.c, 
                         GHB=self.GHB,
                         IBOUND=IBOUND, epsilon=epsilon)

        print('Model was run see model.out, where model is your model name.')

    @property
    def obsNames(self):
        return [p[0] for p in self.points]
    @property
    def r_ow(self):
        return [p[1] for p in self.points]
    @property
    def z_ow(self):
        return [p[2] for p in self.points]


    def show(self, points, **kwargs):
        '''Plot the time-drawdown curves for the observation points.

        parameters
        ----------
        points: list of tuples of (name, r, z)
            names and position of each observation point.
        returns
        -------
            ax : Axis
        '''
        self.points = points

        layNr = self.gr.lrc(self.r_ow, np.zeros_like(self.r_ow), self.z_ow)[:, 0]

        # Numerical solutions interpolated at observation points

        # Get itnepolator but also squeeze out axis 2 (y)
        interpolator = interp1d(self.gr.xm, self.out['Phi'][:, :, 0, :], axis=2)

        # interpolate at radius of observation points
        phi_t = interpolator(self.r_ow)

        # prepare fance selection of iz, ix combinations of obs points
        Ipnt = np.arange(phi_t.shape[-1], dtype=int) # nr of obs points

        phi_t = phi_t[:, layNr, Ipnt] # fancy selection, all times

        ax = kwargs.pop('ax', None)
        if ax is None:
            fig, ax = plt.subplots()
            ax.set_title('Berekend stijghoogteverloop (axiaal model)')
            ax.set_xlabel('t [d]')
            ax.set_ylabel('drawdown [m]')
            ax.grid(True)

        size_inches = kwargs.pop('size_inches', None)
        title  = kwargs.pop('title', None)
        xscale = kwargs.pop('xscale', None)
        yscale = kwargs.pop('yscale', None)
        grid   = kwargs.pop('grid'  , None)

        if size_inches: fig.set_size_inches(size_inches)
        if title: ax.set_title(title)
        if xscale: ax.set_xscale(xscale)
        if yscale: ax.set_yscale(yscale)
        if grid:   ax.grid(grid)

        # Numeric, fdm
        for fi, label, r, z, color in zip(
                phi_t.T, self.obsNames, self.r_ow, self.z_ow, colors):
            ax.plot(self.t[1:], fi[1:], color=color,
                    label='{:6}, r={:>5.0f} m, z={:>3.0f} m'.format(label,r,z),
                     **kwargs)
        ax.legend(loc='best')
        return ax


    def get_psi(self):
        '''Return the stream function psi and store in self.psi.

        stores psi in self.psi

        returns
        -------
            psi (values are in m2/d)
        '''
        Qx = self.out['Qx'][-1][:, 0, :]
        psi = np.cumsum(np.vstack((Qx,
                                   np.zeros_like(Qx[-1:])))[::-1], axis=0)[::-1]
        self.psi = psi
        return psi


    def contour(self, dphi=None, dpsi=None, **kwargs):
        ''''Plot head and contours with streamlines.

        parameters
        ----------
        dphi : float [m]
            head difference between successive contour lines.
        dpsi : float [m2/d]
            amount of water flowing between adjacent stream lines
        additional kwargs:
            passed on to contour fuctions
        '''
        patches = kwargs.pop('patches', None)

        title = kwargs.pop('title',
                   'Stijghoogten en stroomfunctie.')

        if dphi is not None:
            phi = self.out['Phi'][-1][:, 0, :]
            fmin = np.min(phi[np.logical_not(np.isnan(phi))])
            fmax = np.max(phi[np.logical_not(np.isnan(phi))])
            philevels = np.arange(np.floor(fmin), np.ceil(fmax), dphi)

            title + ' dphi={:.3g}m.'.format(dphi)

        if dpsi is not None:
            self.get_psi()
            pmin = np.min(self.psi)
            pmax = np.max(self.psi)
            psilevels = np.arange(np.floor(pmin), np.ceil(pmax), dpsi)

            title + ' dpsi={:.3g}m2/d'.format(dpsi)

        fig, ax = plt.subplots()
        size_inches = kwargs.pop('size_inches', None)
        if not size_inches is None:
            fig.set_size_inches(size_inches)

        ax.set_title(title)
        ax.set_xlabel('r [m]')
        ax.set_ylabel('z [m]')
        ax.grid()

        xlim   = kwargs.pop('xlim',   None)
        ylim   = kwargs.pop('ylim',   None)
        xscale = kwargs.pop('xscale', None)
        yscale = kwargs.pop('yscale', None)

        if not xlim is None: ax.set_xlim(xlim)
        if not ylim is None: ax.set_ylim(ylim)
        if not xscale is None: ax.set_xscale(xscale)
        if not yscale is None: ax.set_yscale(yscale)

        if dphi is not None:
            ax.contour(self.gr.xm,     self.gr.zc, phi, philevels, **kwargs)
        if dpsi is not None:
            ax.contour(self.gr.x[1:-1], self.gr.z, self.psi, psilevels,
                       linestyles='-', colors='b')

        if patches is not None:
            for p in patches:
                ax.add_patch(p)

        return ax
    
def testPars(kw):
    """`Return test parameters given the case kw."""
    z0 = 0.
    z = np.hstack((z0, z0 - np.cumsum(kw['D'])))
    gr = Grid(kw['r'], None, z, axial=True)
    kD = kw['kr'] * kw['D']  
    S = kw['Ss'] * kw['D']  
    Q = 4 * np.pi * kD.sum()
    HI, FQ = gr.const(0.), gr.const(0.)    
    FQ[-1, 0, 0] = Q
    HI[-1] = 0. # exp1(kw['tau'][0])
    IBOUND = gr.const(1, dtype=int)
    Ss = gr.const(kw['Ss'])
    Kr  = gr.const(kw['kr'])
    Kz  = gr.const(kw['kz'])
    return gr, kD, S, Kr, Kz, Ss, Q, HI, FQ, IBOUND

def steady(kw):
    """Return De Glee output in a two-layer axially symmetric layer.
    
    Steady state is computed be setting all Ss = 0. and setting IBOUND < 0 for at least
    one cell or using GHB to fix the model to the outside world.
    Furthermore, use epsilon = 1 to prevent oscillations in early times.
    """
    gr, kD, S, Kr, Kz, Ss, Q, HI, FQ, IBOUND = testPars(kw)
       
    IBOUND[0] = -1 # Top layer fixed.
    Ss.ravel()[:] = 0
    kw['t'] = kw['t'][:2] # only need a single timestep, but more is ok.
     
    c = gr.const(kw['c'])
        
    out = fdm3t(gr=gr, t=kw['t'], kxyz=(Kr, Kr, Kz), Ss=Ss, FQ=FQ, HI=HI, IBOUND=IBOUND, c=c)
    
    xlim = gr.xm[[0, -1]]
    ylim = None # (30., 0.)

    ax = newfig(kw['title'],
        'r [m]', r'$4 \pi kD s / Q$',
        xscale='log', yscale='linear', xlim=xlim, ylim=ylim)
    
    it = len(kw['t']) - 1
    
    ax.plot(gr.xm, out['Phi'][it, -1, 0, :], '.-', label='t={:.3g} d'.format(kw['t'][it]))
    
    B = np.sqrt(kD[-1] * kw['c'].mean())
    x =np.hstack((1e-5, gr.x[1:]))
    deGlee = Q / (2 * np.pi * kD[-1]) * k0(x / B)
    ax.plot(x, deGlee, '-', label='DeGlee')
    
    ax.legend()
    return ax

def theis1(kw):
    """Return Theis output in a one layer axially symmetric layer.
    
    If np.all(Ss == 0.), steady state should be returned. For his at least
    one IBOUND value must be -1 (fixed head). In this test function this is
    done automatically by inspecting Ss.
    """
    gr, kD, S, Kr, Kz, Ss, Q, HI, FQ, IBOUND = testPars(kw)
       
    # Steady case?
    if np.all(Ss == 0):
        IBOUND[:, :, -1] = -1
        epsilon = 1.0
    else: # non-steady case
        u0 = gr.xm ** 2 * S.sum() / (4 * kD.sum() * 0.5 * (kw['t'][0] + kw['t'][1]))
        HI[0] = exp1(u0)
        epsilon = 0.67
        
    out = fdm3t(gr=gr, t=kw['t'], kxyz=(Kr, Kr, Kz), Ss=Ss, FQ=FQ, HI=HI, IBOUND=IBOUND, epsilon=epsilon)

    xlim = kw['t'][[0, -1]]
    ylim = (1e-3, 1e2)

    ax = newfig(kw['title'] + ', function of time, with closed outer boundary',
        't [d]', r'$4 \pi kD s / Q$',
        xscale='log', yscale='log', xlim=xlim, ylim=ylim)
    cc = color_cycler()
    for ir in range(0, gr.nx, 10):
        color = next(cc)
        ax.plot(kw['t'][1:], out['Phi'][1:, 0, 0, ir], '-', color=color, label='r={:.3g} m'.format(gr.xm[ir]))
        u = gr.xm[ir] ** 2 * S.sum() / (4 * kD.sum() * kw['t'])
        ax.plot(kw['t'], exp1(u), '.', label='Theis, color=color, r={:.3g} m'.format(gr.xm[ir]))
    ax.legend()
    
    xlim = gr.xm[[0, -1]]
    ylim = (60., -1.)

    ax = newfig(kw['title'] + ', function of r with closed outer boundary',
        'r [m]', r'$4 \pi kD s / Q$',
        xscale='log', yscale='linear', xlim=xlim, ylim=ylim)
    cc = color_cycler()
    for it in range(0, len(kw['t']), 10):
        color = next(cc)
        ax.plot(gr.xm, out['Phi'][it, 0, 0, :], '-', color=color, label='t={:.3g} d'.format(kw['t'][it]))
        u = gr.xm ** 2 * S.sum() / (4 * kD.sum() * kw['t'][it])
        ax.plot(gr.xm, exp1(u), '.', color=color, label='Theis, t={:.3g} d'.format(kw['t'][it]))
    ax.legend()
    return ax

def theis(kw):
    gr, kD, S, Kr, Kz, Ss, Q, HI, FQ, IBOUND = testPars(kw)
    
    t = kw['r_'] ** 2 * S.sum() / (4 * kD.sum()) * kw['tau']
            
    out = fdm3t(gr=gr, t=t, kxyz=(Kr, Kr, Kz), Ss=Ss, FQ=FQ, HI=HI, IBOUND=IBOUND, epsilon=1.0)

    xlim = None # (1e-1, kw['tau'][-1]) 
    ylim = (1e-2, 1e2)
       
    ax = newfig(kw['title'],
        r'$\tau = r^2 S/(4 kD)$', r'$4 \pi kD s / Q$',
        xscale='log', yscale='log', xlim=xlim, ylim=ylim)
    
    cc = color_cycler()
    for ir in range(1, len(gr.xm), 4):  #, rm in enumerate(gr.xm[1:-1:5]):
        color = next(cc)
        rm = gr.xm[ir]
        u = rm ** 2 * S.sum() / (4 * kD.sum() * t)
        
        tau0 = 1 / u[0] 
        
        ax.plot(1/u, out['Phi'][:, 0, 0, ir], color=color, label="$r_m$={:.3g}, $tau_0$={:.3g}".format(rm, tau0))
        ax.plot(1/u, exp1(u), '.', color=color, label=r"$r_m$={:.3g} m, exp1(u)".format(rm))
        ax.plot(tau0, 2 * ylim[0], 'o', color=color)
    ax.text(1e6, 2 * ylim[0], 'o = corresponds with smallest tau for given r', ha='left', va='center')

    ax.legend()
    plt.show()
    return ax

def hantush1L(kw):
    gr, kD, S, Kr, Kz, Ss, Q, HI, FQ, IBOUND = testPars(kw)
    
    t = kw['r_'] ** 2 * S.sum() / (4 * kD.sum()) * kw['tau']
    
    ax = newfig(kw['title'],
            r'$\tau = r^2 S/(4 kD)$', r'$4 \pi kD s / Q$',
            xscale='log', yscale='log', xlim=kw['tau'][[1, -1]], ylim=(1e-3, 1e2))

    ax.plot(kw['tau'], exp1(1/kw['tau']), 'r-', lw=2, label='Theis')
       
    for rho in kw['rhos']:
        B = kw['r_'] / rho
        ctop = B ** 2  / kD.sum()
        GHB = np.zeros(gr.nx, dtype=ghb_dtype)
        GHB['I'] = gr.NOD[0].ravel()
        GHB['h'] = np.zeros(gr.nx, dtype=float)
        GHB['C'] = gr.Area / ctop
        c=None
        
        out = fdm3t(gr=gr, t=t, kxyz=(Kr, Kr, Kz), Ss=Ss, FQ=FQ, HI=HI, IBOUND=IBOUND, c=c, GHB=GHB, epsilon=1.0)
        
        points = (kw['tau'], gr.xm)
        interp = RegularGridInterpolator(points=points, values=out['Phi'][:, -1, 0, :], method='linear')
        xi = np.vstack((kw['tau'], np.ones_like(kw['tau']) *  kw['r_'])).T
        ax.plot(kw['tau'], interp(xi), '-', marker='.', label="rho={:.4g}".format(rho))
    
    ax.legend()
    plt.show()
    return ax


def hantush2L(kw):
    gr, kD, S, Kr, Kz, Ss, Q, HI, FQ, IBOUND = testPars(kw)
    
    t = kw['r_'] ** 2 * S[-1] / (4 * kD[-1]) * kw['tau']
    
    ax = newfig(kw['title'],
            r'$\tau = r^2 S/(4 kD)$', r'$4 \pi kD s / Q$',
            xscale='log', yscale='log', xlim=kw['tau'][[1, -1]], ylim=(1e-3, 1e2))

    ax.plot(kw['tau'], exp1(1/kw['tau']), 'r-', lw=2, label='Theis')
       
    for rho in kw['rhos']:
        B = kw['r_'] / rho
        ctop = B ** 2  / kD.sum()        
        IBOUND[0] = -1
        GHB = None
        c = gr.const(0.)[:-1]; c[0] = ctop
        
        out = fdm3t(gr=gr, t=t, kxyz=(Kr, Kr, Kz), Ss=Ss, FQ=FQ, HI=HI, IBOUND=IBOUND, c=c, GHB=GHB, epsilon=1.0)

        points = (kw['tau'], np.arange(gr.nlay), gr.xm)
        interp = RegularGridInterpolator(points=points, values=out['Phi'][:, :, 0, :], method='linear')
        xi = np.vstack((kw['tau'], np.ones(len(kw['tau'])) * gr.nlay - 1, np.ones_like(kw['tau']) *  kw['r_'])).T
        ax.plot(kw['tau'], interp(xi), '-', label="rho={:.4g}".format(rho))
        ax.plot(kw['tau'], Wh(1/kw['tau'], rho)[0], '.', label=r'$Wh(1/\tau, \rho)$'.format(rho))

    ax.legend()
    plt.show()
    return ax

def boulton(kw):
    gr, kD, S, Kr, Kz, Ss, Q, HI, FQ, IBOUND = testPars(kw)
    
    t = kw['r_'] ** 2 * S.sum() / (4 * kD.sum()) * kw['tau']

    ax = newfig(kw['title'],
            r'$\tau = r^2 S/(4 kD)$', r'$4 \pi kD s / Q$',
            xscale='log', yscale='log', xlim=kw['tau'][[1, -1]], ylim=(1e-3, 1e2))

    ax.plot(kw['tau'],              exp1(1/kw['tau']), 'r-', lw=2, label='Theis [Sy]')
    ax.plot(kw['tau'] * S[1] /S[0], exp1(1/kw['tau']), 'r-', lw=2, label='Theis [S]')
    
    for rho in kw['rhos']:
        B = kw['r_'] / rho
        ctop = B ** 2  / kD.sum()        
        IBOUND[0] = 1
        GHB = None
        c = gr.const(0.)[:-1]; c[0] = ctop
        
        out = fdm3t(gr=gr, t=t, kxyz=(Kr, Kr, Kz), Ss=Ss, FQ=FQ, HI=HI, IBOUND=IBOUND, c=c, GHB=GHB, epsilon=1.0)

        points = (kw['tau'], np.arange(gr.nlay), gr.xm)
        interp = RegularGridInterpolator(points=points, values=out['Phi'][:, :, 0, :], method='linear')
        
        xi = np.vstack((kw['tau'], np.ones(len(kw['tau'])) * gr.nlay - 1, np.ones_like(kw['tau']) *  kw['r_'])).T
        ax.plot(kw['tau'], interp(xi), label="rho={:.4g}".format(rho))                            
        
        xi = np.vstack((kw['tau'], np.ones(len(kw['tau'])) * 0, np.ones_like(kw['tau']) *  kw['r_'])).T
        ax.plot(kw['tau'], interp(xi), label="rho={:.4g}".format(rho))            
        
        ax.plot(kw['tau'] * S[1]/S[0], Wh(1/kw['tau'], rho)[0], '.', label=r'$Wh(1/\tau, \rho)$'.format(rho))
        
    ax.legend()
    plt.show()
    return ax

if __name__ == '__main__':
        
    cases = {
        'steady':
            {'title': 'steady',
             "comment": """This test is to verify the accuracy of the model against an analytical
             solution of Theis or even Hantush by a regular simulation, no dimensionless parameters.
             """,
            't': np.logspace(-4, 9, 131),
            'r': np.hstack((0, np.logspace(-2, 6, 81))),
            'D': np.array([  10., 50.]),
            'kr': np.array([ 1e-6, 10.]),
            'kz': np.array([ 1e6,  1e6]),
            'Ss': np.array([ 0.01, 0.2e-6]),
            'c': np.array([[600.]])
             },
        'test0':
            {'title': 'test',
             "comment": """This test is to verify the accuracy of the model against an analytical
             solution of Theis or even Hantush by a regular simulation, no dimensionless parameters.
             """,
            't': np.logspace(-4, 9, 131),
            'r': np.hstack((0., np.logspace(-2, 6, 81))),
            'D': np.array([50.]),
            'kr': np.array([10.]),
            'kz': np.array([1e6]),
            'Ss': np.array([0.2e-6]),
            'r_' :30.,
            'rhos': [0.01, 0.03, .1, .3, 1., 3.],             
             },
        'Theis':
            {'title': r"""Theis numeric
             $\tau_0$ corresponds to the smallest time for given $r$""",
             'comment': """Theis numeric. Computes theis at dimensionloss scale tau = 1/u.
             The numeric model computes ones the drawdown for many t and r, which results in
             Phi[nt, nlay, ny, nr]. To get the dimensionless drawdown, Q = 4 pi kD. The dimensionless
             time is tau = 4 kD S * t / r ** 2. Hence a single kind of reference r has to be chosen in
             a single plot. By plotting multiple limes, each time chosing a different ref. distance,
             we get parts of the Theis curve on a dimensionless time scale tau as if each curve was
             drawn for a different piezometer. In fact, by fixing tau, while choosing another r for
             each curve we show the piezometer results with different times, as if they were measured
             at different times. For points curves with large reference r, the times start at high             
             values (late) which causes the graphs to start seemingly wrong on early times, which is
             an artefact that can be removed by broading the time span.
             """,
            'tau': np.logspace(-5, 9, 141), # tau = 1/ u
            'r': np.hstack((0., np.logspace(-2, 6, 81))),
            'D': np.array([50.]),
            'kr': np.array([10.]),
            'kz': np.array([1e6]),
            'Ss': np.array([1e-5]),
            'r_' :30.,
            'rhos': [0.01, 0.03, .1, .3, 1., 3.],
            },
        'Hantush1L':
            {'title' : 'Hantush using 1 layer and GHB',
            'comment': """Hantush is numerically simlated using a single model layer, the inflow
            at the top is made using general head boundaries. This result should be the same
            as the one alled Hantush 2L. It's a way to verify that the GHB has been implemented correctly.
            """,
            'tau': np.logspace(-5, 9, 141), # tau = 1/ u
            'r': np.hstack((0., np.logspace(-2, 6, 81))),
            'D': np.array([50.]),
            'kr': np.array([10.]),
            'kz': np.array([1e6]),
            'Ss': np.array([0.2e-6]),
            'r_' :30.,
            'rhos': [0.01, 0.03, .1, .3, 1., 3.],
            },
        'Hantush2L': {
            'title': 'Hantush using 2 layers',
            'comment': """Hantush is simulated using 2 layer. One is the top layer with fixed head and
            given resistance between the first and second layer. The second layer is the aquifer. This
            example also serves to verify the implementation of the interlayer resistance 'c'.
            """,
            'tau': np.logspace(-5, 9, 141), # tau = 1/ u
            'r': np.hstack((0., np.logspace(-2, 6, 81))),
            'D': np.array([  10., 50.]),
            'kr': np.array([ 1e-6, 10.]),
            'kz': np.array([ 1e6,  1e6]),
            'Ss': np.array([ 0.01, 0.2e-6]),
            'r_' :30.,
            'rhos': [0.01, 0.03, .1, .3, 1., 3.],
            },
        'Boulton63': {
            'title': 'Boulton 1963, delayed yield',
            'comment': """Boulton is simulated using 2 layers. One is the top layer with given Sy and
            given resistance between the first and second layer. The second layer is the aquifer with
            elastic storage coefficient S. The resisance between the two layers follows from the
            value of rho used. A single reference distance r_ is used for all curve. This has no effect
            on the results because these are given on dimensionless graphs.
            """,
            'tau': np.logspace(-5, 9, 141), # tau = 1/ u
            'r': np.hstack((0., np.logspace(-2, 6, 81))),
            'D': np.array([  10., 50.]),
            'kr': np.array([ 1e-6, 10.]),
            'kz': np.array([ 1e6,  1e6]),
            'Ss': np.array([  0.01, 0.2e-6]),
            'r_' :30.,
            'rhos': [0.01, 0.03, .1, .3, 1., 3.],
            }
        }
    
    print('Available cases:\n{}'.format(cases.keys()))
    
    #steady(cases['steady'])
    theis1(cases['test0'])
    #theis(cases['Theis'])
    #hantush1L(cases['Hantush1L'])
    #hantush2L(cases['Hantush2L'])
    #boulton(cases['Boulton63'])

    plt.show()