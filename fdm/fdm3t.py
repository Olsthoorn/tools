"""A finite difference model for ransient groundwater flow is implemented.
The implementation is in the function fdm3t. Some other modules are used
that are in subdirectories of the tools folder. One may change the line that
includes the tools folde to an absolute path on a specific computer.

The model has also been wrapped in thte class Fdm3t.

Under __main__ are several tests that have been implemented as functions
themselves to prevent clutter under __main__.

The data for the different tests are collectd in a dictionary 'cases'.
"""
# %%
import os
import sys

# sys.path.insert(0, os.path.abspath('../')) # Start in the subdirectory of tools

import warnings
import numpy as np
import matplotlib.pyplot as plt
import scipy.sparse as sp
from scipy.special import exp1, k0
from scipy.sparse.linalg import spsolve # to use its short name
from scipy.interpolate import RegularGridInterpolator as interp1d
from matplotlib import colors

# In Tools folder:
from analytic.hantush_convolution import Wh
from fdm.mfgrid import Grid
from etc import newfig, color_cycler

print('Wh(0.001, 0.3)  =', Wh(0.001, 0.3))
print('Wh(0.01, 0.3)   =', Wh(0.01, 0.3))
print('Wh(0.1, 0.3)    =', Wh(0.1, 0.3))

# %%
class InputError(Exception):
    """Define Input Error class."""
    pass

dtypeQ   = np.dtype([('I', int), ('q', float)])
dtypeH   = np.dtype([('I', int), ('h', float)])
dtypeGHB = np.dtype([('I', int), ('h', float), ('C', float)])

def fdm3t(gr=None, t=None, k=None, c=None, ss=None, fh=None, ghb=None,
          fq=None, hi=None, idomain=None, epsilon=0.67):
    """Transient 3D Finite Difference Model returning computed heads and flows.

    Heads and flows are returned as 3D arrays as specified under output parmeters.
    
    Steady-state flow is computed when setting Ss = 0 for all Ss and making
    sure at least one cell has a fixed head, i.e. one with FH specified.
    For steady state, also use epsilon = 1, to prevent oscillatioin in the results
    of the first times.

    Parameters
    ----------
    gr : `grid_object`, generated by gr = Grid(x, y, z, ..)
        if `gr.axial`==True, then the model is run in axially symmetric model
    t : ndarray, shape: [Nt+1]
        times at which the heads and flows are desired including the start time,
        which is usually zero, but can have any value.
    k: 2 or 3-tuple of ndarray, shape: (Nz, Ny, Nx), [L/T]
        hydraulic conductivities along the three axes, 3D arrays.
    c: nd.array of shape (Nz-1, Ny, Nx) or (Nz, Nx, Ny) or (Nz+1, Ny, Nx)
        vertical resistances between the layers
            - between the layers if shape(0) == nlay - 1
            - includes above top layer if shape(0) = nlay
            - includes both  top and bottom layers if shape(0) = nlay + 1
        may be None
    ss : ndarray, shape: (Nz, Ny, Nx), [L-1]
        specific elastic storage
    fh : Fixed-flow boundaries dict{ it: recarray, ...}
        recarray with dtype = np.dtype([('I', int), ('h', float)])        
    ghb: General head boundaries dict {it: recarray, ...}
        recarray with dtype = np.dtype([(I, 'int'), ('h', float), ('C', float)])   
    fq : Fixed-flow boundaries dict{ it: recarray, ...}
        recarray with dtype = np.dtype([('I', int), ('Q', float)])
    fh:  Fixed-head or perscribed heads dict {it: recarray, ....}
        recarray dtype = np.dtype([('I', int), ('h', float)])
    hi : ndarray, shape: (Nz, Ny, Nx), [L]
        initial heads. `IH` has the prescribed heads for the cells with prescribed head.
    idomain : ndarray, shape: (Nz, Ny, Nx) of int
        boundary array like in MF6, flow-through cells not supported
        * idomain=0   cells are inactive, will be given value NaN
        * idomain!=0  cells are active
    epsilon : float, dimension [-]
        degree of implicitness, choose value between 0.5 and 1.0

    outputs
    -------
    out : dictionary gr, time, heads and flows:
        out['gr]: mfgrid.Grid objecy (holding the network)
        out['t']: array of times including the time of the initial head.
        out['Phi'] : ndarray, shape: (Nt+1, Nz, Ny, Nx), [L3/T]
            computed heads. Inactive cells will have NaNs
            To get heads at time t[i], use Out.Phi[i]
            Out.Phi[0] = initial heads
        out['Q']   : ndarray, shape: (Nt, Nz, Ny, Nx), [L3/T]
            net inflow in all cells during time step, inactive cells have 0
            Q during time step i, use Out.Q[i]
        out['Qs']  : ndarray, shape: (Nt, Nz, Ny, Nx), [L3/T]
            release from storage during time step.
        out['Qx']   : ndarray, shape: (Nt, Ny, Nx-1, Nz), [L3/T]
            intercell flows in x-direction (parallel to the rows)
        out['Qy']  : ndarray, shape: (Nt, Ny-1, Nx, Nz), [L3/T]
            intercell flows in y-direction (parallel to the columns)
        out['Qz']  : ndarray, shape: (Nt, Nz, Ny, Nx-1), [L3/T]
            intercell flows in z-direction (vertially upward postitive)
        out['GHB'] : ndarray of gr.shape of general head boundary inflows if GHB is not None.

    TO 161024, 230418
    """
    if gr.axial:
        print('Running in axial mode, y-values are ignored.')

        kx, ky, kz = gr.check_array_tuple(k)
    
    if c is not None:
        if isinstance(c, np.ndarray):
            if not np.all(c.shape == (gr.nlay -1, gr.ny, gr.nx)):
                raise AssertionError(f"shape c ({c.shape}) should be {(gr.nlay - 1, gr.ny, gr.nx)}")

    active = (idomain != 0).reshape(gr.nod,)  # boolean vector denoting the active cells
    inact  = (idomain == 0).reshape(gr.nod,)  # boolean vector denoting inacive cells

    if fh is not None:
        fh = gr.check_sarray_dict(fh, dtype=dtypeH)
    if fq is not None:
        fq = gr.check_sarray_dict(fq, dtype=dtypeQ)
    if ghb is not None:
        ghb = gr.check_sarray_dict(ghb, dtype=dtypeGHB)
    
    if ss is None:
        if fh is None and ghb is None:
            raise ValueError('If all ss == 0, at FQ or ghb must be used.')
        epsilon = 1.0 # Prevents oscillations in early times

    # reshaping shorthands
    dx = np.reshape(gr.dx, (1, 1, gr.nx))
    dy = np.reshape(gr.dy, (1, gr.ny, 1))

    # half cell flow resistances
    if not gr.axial:
        rxe = 0.5 *    dx / (   dy * gr.DZ) / kx
        rxw = rxe
        ry = 0.5 *    dy / (gr.DZ *    dx) / ky
        rz = 0.5 * gr.DZ / (   dx *    dy) / kz  
        rc  = 0 if c is None else c   / (dx * dy)
    else:
        with warnings.catch_warnings():
            # Division  by zero when x==0, is ok --> np.inf as resistance.
            warnings.simplefilter("ignore", category=RuntimeWarning)
            rxw = 1 / (2 * np.pi * kx * gr.DZ) * np.log(gr.xm / gr.x[:-1]).reshape((1, 1, gr.nx))
            rxe = 1 / (2 * np.pi * kx * gr.DZ) * np.log(gr.x[1:] /  gr.xm).reshape((1, 1, gr.nx))
        ry = np.inf * np.ones(gr.shape)
        rz = 0.5 * gr.DZ / (np.pi * (gr.x[1:] ** 2 - gr.x[:-1] ** 2).reshape((1, 1, gr.nx)) * kz)
        rc  = 0 if c is None else c   / (
            np.pi * (gr.x[1:] ** 2 - gr.x[:-1] ** 2).reshape((1, 1, gr.nx))
            )

    # set flow resistance in inactive cells to infinite
    rxw[inact.reshape(gr.shape)] = np.inf
    rxw[inact.reshape(gr.shape)] = np.inf
    ry[inact.reshape(gr.shape)] = np.inf
    rz[inact.reshape(gr.shape)] = np.inf

    # conductances between adjacent cells
    cx = 1 / (rxw[: , :,1:] + rxe[:  ,:  ,:-1])
    cy = 1 / (ry[: ,1:, :] + ry[:  ,:-1,:  ])
    cz = 1 / (rz[1:, :, :] + rc + rz[:-1,:  ,:  ])

    # storage term, variable dt not included
    if ss is not None:
        Cs = ss * gr.DZ * gr.Area[np.newaxis, :, :, ] / epsilon

    # cell number of neighboring cells
    IW = gr.NOD[:,:,:-1]  # east neighbor cell numbers
    IE = gr.NOD[:,:, 1:] # west neighbor cell numbers
    IN = gr.NOD[:,:-1,:] # north neighbor cell numbers
    IS = gr.NOD[:, 1:,:]  # south neighbor cell numbers
    IT = gr.NOD[:-1,:,:] # top neighbor cell numbers
    IB = gr.NOD[ 1:,:,:]  # bottom neighbor cell numbers

    R = lambda x : x.ravel()  # generate anonymous function R(x) as shorthand for x.ravel()

    # notice the call  csc_matrix( (data, (rowind, coind) ), (M,N))  tuple within tupple
    # also notice that Cij = negative but that Cii will be postive, namely -sum(Cij)
    A = sp.csc_matrix(( np.concatenate(( R(cx), R(cx), R(cy), R(cy), R(cz), R(cz)) ),\
                        (np.concatenate(( R(IE), R(IW), R(IN), R(IS), R(IT), R(IB)) ),\
                         np.concatenate(( R(IW), R(IE), R(IS), R(IN), R(IB), R(IT)) ),\
                      )),(gr.nod,gr.nod))

    # Change sign and add diagonal
    A = -A + sp.diags( np.array(A.sum(axis=1)).ravel() )

    #Initialize output arrays (= memory allocation)
    if t is None:
        nt, ndt, t = 2, 1, np.array([0., 1.])
    else:
        nt, ndt = len(t), len(t)-1
    Phi = np.zeros((ndt+1, gr.nod)) # Nt+1 times
    Q   = np.zeros((ndt,   gr.nod)) # Nt time steps
    Qs  = np.zeros((ndt,   gr.nod))
    Qghb= np.zeros((ndt,   gr.nod))

    Qx  = np.zeros((ndt, gr.nz, gr.ny, gr.nx-1))
    Qy  = np.zeros((ndt, gr.nz, gr.ny-1, gr.nx))
    Qz  = np.zeros((ndt, gr.nz-1, gr.ny, gr.nx))

    # reshape input arrays to vectors for use in system equation
    
    if ss is not None:
        Cs = R(Cs)
    
    # initialize heads
    if hi is not None:
        Phi[0] = hi.flatten()
    rhs  = np.zeros(gr.shape).flatten()
    fQ   = np.zeros(gr.shape).flatten()
    ghbc = np.zeros(gr.shape).flatten()
    ghbh = np.zeros(gr.shape).flatten()
    dia  = np.zeros(gr.shape).flatten()
    act_it = active[:]
    
    # solve heads at active locations not fixed head at t_i+eps*dt_i
    for idt, dt in enumerate(np.diff(t)):
        it = idt + 1
        rhs[:] = 0.
        dia[:] = 0.
                 
        if fq is not None:   
            if idt in fq: # update fq
                fQ[:] =0.          
                fQ[fq[idt]['I']] = fq[idt]['q']
            if idt >= tuple(fq.keys())[0]:
                rhs += fQ
        
        if ghb is not None:
            if idt in ghb: # update ghb
                ghbc[:] = 0.
                ghbh[:] = 0.
                ghbc[ghb[idt]['I']] = ghb[idt]['C']
                ghbh[ghb[idt]['I']] = ghb[idt]['h']
            if idt >= tuple(ghb.keys())[0]:
                dia += ghbc
                rhs += ghbc * ghbh
        
        if ss is not None: # update Cs / dt
            dia += Cs / dt
            rhs += Cs / dt * Phi[it - 1]

        if fh is not None:            
            if idt in fh: # update fh                          
                Ifh, hfh = fh[idt]['I'], fh[idt]['h']            
                isfh = gr.const(0., dtype=bool).ravel()
                isfh[Ifh]    = True
            if idt >= tuple(fh.keys())[0]:
                Phi[it][Ifh] = hfh
                fh_rhs = (A + sp.diags(dia))[:, Ifh].dot(Phi[it][Ifh])
                act_it = np.logical_and(active, np.logical_not(isfh))
                rhs -= fh_rhs
        
        Phi[it][act_it] = spsolve( (A + sp.diags(dia))[act_it][:,act_it], rhs[act_it])

        # net cell inflow
        Q[idt]  = A.dot(Phi[it])

        if ss is not None:
            Qs[idt] = -Cs/dt * (Phi[it]-Phi[it-1])

        #Flows across cell faces
        Qx[idt] =  -np.diff( Phi[it].reshape(gr.shape), axis=2) * cx
        Qy[idt] =  +np.diff( Phi[it].reshape(gr.shape), axis=1) * cy
        Qz[idt] =  +np.diff( Phi[it].reshape(gr.shape), axis=0) * cz
        
        if ghb is not None:
            Qghb[idt] = (ghbh.ravel() - Phi[it]) * ghbc.ravel()

        # update head to end of time step
        Phi[it][act_it] = Phi[it-1][act_it] + (Phi[it]-Phi[it-1])[act_it] / epsilon
        #Phi[it][active] = Phi[it-1][active] + (Phi[it]-Phi[it-1])[active] / epsilon
        Phi[it][inact]  = np.nan

    # reshape Phi to shape of grid
    Phi  =  Phi.reshape((nt, ) + gr.shape)
    Q    =    Q.reshape((ndt,) + gr.shape)
    Qs   =   Qs.reshape((ndt,) + gr.shape)
    Qghb = Qghb.reshape((ndt,) + gr.shape)
    
    out = dict()
    out.update(gr=gr, t=t, Phi=Phi, Q=Q, Qs=Qs, Qx=Qx, Qy=Qy, Qz=Qz, Qghb=Qghb)

    return out

class Fdm3t:
    """Class of transient finite difference groundwater model.
    
    Wraps the function fdm3t in it.    
    """

    def __init__(self, gr=None, t=None, k=None, ss=None, fh=None, fq=None, hi=None,
                 c=None, ghb=None, idomain=None, epsilon=1.0):
        """Instantiate a 3D transient axially symmetric groundwater
        finite difference model.

        All model arrays must have shape [nlay, nrow, ncol]. This is so
        even if an axially symmetric model has only one row.

        parameters
        ----------
        gr : mfgrid.Grid object
            contains the computation finite difference network.
        t : time, numpy.ndarray
            if 0 is not included, it will be added to store
            the initial heads for t=0.
        k : tuple of (Kr, Kz) or (Kr, Ky, Kz)
            Ky is ignored.
        ss : ndarray of gr.shape
            Specifici storage coefficients.
        fh: ndarray of gr.shape
            fixed head per modflow cell.
            This could be specified as a dict[isp] where isp is the
            stress-period number.
        fq : ndarray of gr.shape
            fixed infiltration per modflow cell. Extractions are
            negative.
            This could be specified as a dict[isp] where isp is the
            stress-period number.
        hi : ndarray of gr.shape.
            initial heads and fixed heads.
            The heads are fixed where IDOMAIN<0.
            This could be specified as a dict[isp] where isp is the
            stress-period number. In that case, the heads at the
            nodes with IDOMAIN<0 will be replaced by the fixed heads
            speciied for the stress period.
        c: np.ndarray of shape (gr.nlay - 1, gr.nrow, gr.ncol)
            The vertical resistance in between the model layers.
        ghb: np.recarray of dtype =np.dtype([('I', int), ('h', float), ('C', float)])
            Specifies general head boundaries.
        idomain : ndarray of dtype int of size gr.shape
            Boundary array like in MODFLOW. <0 means head is
            prescribed for the cell; 0 means cell is inactive, >0 means,
            head will be compute for the cell.
        epsilon : float between 0.5 and 1.
            Implicitness. 0.5 is indifferently stable (Crank Nicholson
            scheme of updating future head, most accurate), 1 is completely
            implicit, most stable, but sometimes a bit less accurate.e
            Modflow uses epsilon=1 implicitly.
            
        returns
        -------
        self.out : dictionary
            the simulation results: Phi, Q, Qx, Qy, Qz, Qs
            ndarrays with time as first dimension.
        """
        if isinstance(k, (tuple, list)):
            if len(k)==3:
                kh, _, kv = k
            elif len(k) == 2:
                kh, kv = k
            elif len(k) == 1:
                kh = k[0]
                kv = kh
            else:
                raise ValueError("Can't understand input k, use (Kx, Kz) tuple")
        else:
            kh = k
            kv = k

        assert np.all(gr.shape == kh.shape), 'gr.shape != kh.shape'
        assert np.all(gr.shape == kv.shape), 'gr.shape != kv.shape'
        assert np.all(gr.shape == fh.shape), 'gr.shape != fh.shape'
        assert np.all(gr.shape == fq.shape), 'gr.shape != fq.shape'
        assert np.all(gr.shape == ss.shape), 'gr.shape != hi.shape'
        assert np.all(gr.shape == idomain.shape), 'gr.shape != idomain.shape'

        self.gr = gr
        self.t  = t
        self.kh = kh
        self.kv = kv
        self.c  = c
        self.ss = ss
        self.fq = fq
        self.hi = hi
        self.c = c
        self.ghb = ghb
        self.idomain = idomain
        self.psi = None

        # Immediately runs the model and stores its output
        self.out = fdm3t(gr=self.gr, t=self.t,
                         k=(self.kh, self.kh, self.kv),
                         ss=self.ss, fq=self.fq, hi=self.hi, c=self.c, 
                         ghb=self.ghb,
                         idomain=self.idomain, epsilon=epsilon)

        print('Model was run see model.out, where model is your model name.')

    @property
    def obsNames(self):
        """Return names of observation points."""
        return [p[0] for p in self.points]
    @property
    def r_ow(self):
        return [p[1] for p in self.points]
    @property
    def z_ow(self):
        return [p[2] for p in self.points]


    def show(self, points, **kwargs):
        '''Plot the time-drawdown curves for the observation points.

        parameters
        ----------
        points: list of tuples of (name, r, z)
            names and position of each observation point.
        returns
        -------
            ax : Axis
        '''
        self.points = points

        layNr = self.gr.lrc(self.r_ow, np.zeros_like(self.r_ow), self.z_ow)[:, 0]

        # Numerical solutions interpolated at observation points

        # Get interpolator but also squeeze out axis 2 (y)
        interpolator = interp1d(self.gr.xm, self.out['Phi'][:, :, 0, :], axis=2)

        # interpolate at radius of observation points
        phi_t = interpolator(self.r_ow)

        # prepare fance selection of iz, ix combinations of obs points
        Ipnt = np.arange(phi_t.shape[-1], dtype=int) # nr of obs points

        phi_t = phi_t[:, layNr, Ipnt] # fancy selection, all times

        ax = kwargs.pop('ax', None)
        if ax is None:
            fig, ax = plt.subplots()
            ax.set_title('Berekend stijghoogteverloop (axiaal model)')
            ax.set_xlabel('t [d]')
            ax.set_ylabel('drawdown [m]')
            ax.grid(True)

        size_inches = kwargs.pop('size_inches', None)
        title  = kwargs.pop('title', None)
        xscale = kwargs.pop('xscale', None)
        yscale = kwargs.pop('yscale', None)
        grid   = kwargs.pop('grid'  , None)

        if size_inches:
            plt.gcf().set_size_inches(size_inches)
        if title:
            ax.set_title(title)
        if xscale:
            ax.set_xscale(xscale)
        if yscale:
            ax.set_yscale(yscale)
        if grid:
            ax.grid(grid)

        # Numeric, fdm
        for fi, label, r, z, color in zip(
                phi_t.T, self.obsNames, self.r_ow, self.z_ow, colors):
            ax.plot(self.t[1:], fi[1:], color=color,
                    label=f'{label:6}, r={r:>5.0f} m, z={z:>3.0f} m',
                     **kwargs)
        ax.legend(loc='best')
        return ax


    def get_psi(self):
        '''Return the stream function psi and store in self.psi.

        stores psi in self.psi

        returns
        -------
            psi (values are in m2/d)
        '''
        Qx = self.out['Qx'][-1][:, 0, :]
        psi = np.cumsum(np.vstack((Qx,
                                   np.zeros_like(Qx[-1:])))[::-1], axis=0)[::-1]
        self.psi = psi
        return psi


    def contour(self, dphi=None, dpsi=None, **kwargs):
        ''''Plot head and contours with streamlines.

        parameters
        ----------
        dphi : float [m]
            head difference between successive contour lines.
        dpsi : float [m2/d]
            amount of water flowing between adjacent stream lines
        additional kwargs:
            passed on to contour fuctions
        '''
        patches = kwargs.pop('patches', None)

        title = kwargs.pop('title',
                   'Stijghoogten en stroomfunctie.')

        if dphi is not None:
            phi = self.out['Phi'][-1][:, 0, :]
            fmin = np.min(phi[np.logical_not(np.isnan(phi))])
            fmax = np.max(phi[np.logical_not(np.isnan(phi))])
            philevels = np.arange(np.floor(fmin), np.ceil(fmax), dphi)

            title += f' dphi={dphi:.3g}m.'

        if dpsi is not None:
            self.get_psi()
            pmin = np.min(self.psi)
            pmax = np.max(self.psi)
            psilevels = np.arange(np.floor(pmin), np.ceil(pmax), dpsi)

            title += f' dpsi={dpsi:.3g}m2/d'

        fig, ax = plt.subplots()
        size_inches = kwargs.pop('size_inches', None)
        if size_inches is not None:
            fig.set_size_inches(size_inches)

        ax.set_title(title)
        ax.set_xlabel('r [m]')
        ax.set_ylabel('z [m]')
        ax.grid()

        xlim   = kwargs.pop('xlim',   None)
        ylim   = kwargs.pop('ylim',   None)
        xscale = kwargs.pop('xscale', None)
        yscale = kwargs.pop('yscale', None)

        if xlim is not None:
            ax.set_xlim(xlim)
        if ylim is not None:
            ax.set_ylim(ylim)
        if xscale is not None:
            ax.set_xscale(xscale)
        if yscale is not None:
            ax.set_yscale(yscale)

        if dphi is not None:
            ax.contour(self.gr.xm,     self.gr.zc, phi, philevels, **kwargs)
        if dpsi is not None:
            ax.contour(self.gr.x[1:-1], self.gr.z, self.psi, psilevels,
                       linestyles='-', colors='b')

        if patches is not None:
            for p in patches:
                ax.add_patch(p)

        return ax


def deGlee(r=None, D=None, kr=None, kz=None, c=None, use_ghb=False, **kw):
    """Return De Glee output in a two-layer axially symmetric layer.
    
    Steady state is computed be setting all ss = 0.  if c is given ghb is used else, kz is use
    to set the resistance.
    
    Returns the besselfunction because Q = 2 * np.kD
    
    Parameters
    ----------
    gr: mfgrid.Grid object
        the grid
    kr, kz: float, 3D arrays of horizontal and vertical conductivities
        kr, kz conductivities
    """
    kD = (kr * D).sum()
    ctop = c
    L = np.sqrt(kD * c)
    Q = 2 * np.pi * kD
    
    z = -np.cumsum(np.hstack((0, D)))
    
    gr = Grid(r, [-0.5, 0.5], z, axial=True)
    
    kr = kr[:, np.newaxis, np.newaxis] * gr.const(1.)
    kz = kz[:, np.newaxis, np.newaxis] * gr.const(1.)
    
    fq = np.zeros(1, dtype=dtypeQ)
    fq['I'], fq['q'] = gr.NOD[-1, 0, 0], Q
    fq = {0: fq}
    
    if use_ghb:
        # use ghb instead of c. So fh must be None as well as c
        ghb = np.zeros(gr.nx * gr.ny, dtype=dtypeGHB)
        ghb['I'], ghb['C'], ghb['h'] = gr.NOD[-1].ravel(), gr.Area.ravel() / c, 0.
        ghb = {0: ghb}
        fh = None
        c = None        
    else:
        #use c insteand of ghb, so ghb must be None and fh and c must be set to None
        fh = np.zeros(gr.nx * gr.ny, dtype=dtypeH)
        fh['I'], fh['h'] = gr.NOD[0].ravel(), 0.
        fh = {0: fh}
        c = gr.const(0.)[:-1]
        c[0] = ctop
        ghb = None
    
    idomain = gr.const(1, dtype=int)
    hi = gr.const(0.)

    out = fdm3t(gr=gr, t=None, k=(kr, kr, kz), c=c,
                fh=fh, fq=fq, ghb=ghb,
                hi=hi, idomain=idomain)

    ax = newfig('De Glee example',
        'r [m]', 'drawdown',
        xscale='log', yscale='linear')
    ax.invert_yaxis()

    ax.plot(gr.xm, out['Phi'][-1, -1, 0, :], '.-', label='numerical')

    ax.plot(gr.xm, Q / (2 * np.pi * kD) * k0(gr.xm / L), '-', label='DeGlee')

    ax.legend()
    return ax

def theis1(um1=None, r=None, D=None, kr=None, kz=None, ss=None, r_=None, **kw):
    """Return Theis output in a one-layer axially symmetric model.
    
    If np.all(ss == 0.), steady state should be returned. For his at least
    one cell must be fixed head (as specified by fh).
    """
    
    kD = (kr * D).sum()
    S  = (ss * D).sum()

    z = -np.cumsum(np.hstack((0, D)))
    gr = Grid(r, [-0.5, 0.5], z, axial=True)
    idomain = gr.const(1, dtype=int)

    Q = 4 * np.pi * kD
        
    ir = np.arange(gr.nx + 1)[r < 60][-1]
    t = um1 * r[ir] ** 2 * S / (4 * kD)

    hi = gr.const(0.)
    hi[0, 0, :] = Q / (4 * np.pi * kD) * exp1(gr.xm ** 2 * D  / (4 * kD * t[0]))

    fq = np.zeros(1, dtype=dtypeQ)
    fq['I'], fq['q'] = gr.NOD[-1, 0, 0], Q
    fq = {0: fq}
    

    fh = np.zeros(gr.nz * gr.ny, dtype=dtypeH)
    fh['I'], fh['h'] = gr.NOD[:, :, -1].ravel(), 0
    fh = {0: fh}
    fh = None

    out = fdm3t(gr=gr, t=t, k=(kr, kr, kz), ss=ss, fh=fh, fq=fq, hi=hi, idomain=idomain)

    xlim = np.logspace(-2, 6, 2)
    ylim = np.logspace(-4, 1, 2)
    
    ax = newfig(kw['title'],
        'r increases <---- (4 kD / S) t / r^2 [-] ----> time increase' ,
        's / (Q / (4 pi kD)) [-]',
        xscale='log', yscale='log',
        xlim=xlim, ylim=ylim)
    
    cc = color_cycler()
    # select a few distances for which the show the graph
    for ir in range(0, gr.nx, 10):
        color = next(cc)        
        rm = gr.xm[ir]
        if rm < 1.0 or rm > 1000.:
            continue
        ax.plot((4 * kD  / S) * (t / rm ** 2), out['Phi'][:, -1, 0, ir] / (Q / (4 * np.pi * kD)), '-', color=color, label=f'r={gr.xm[ir]:.3g} m')
               
    ax.plot(um1, exp1(1 / um1), '.', label=f'Theis, r={gr.xm[ir]:.3g} m')
    ax.legend()
    return ax

def hantush(um1=None, r=None, kr=None, kz=None, D=None, ss=None, rhos=None, use_ghb=False, **kw):
    """Show hantush well function using two layer model."""
    
    # c is not used, it's obtained for the given rho = r / lambda
    
    kD = (kr * D).sum()
    S  = (ss * D).sum()
    Q = 4 * np.pi * kD
    
    z =- np.hstack((0, D)).cumsum()
        
    gr = Grid(r, [-0.5, 0.5], z, axial=True)
    
    if gr.nlay == 1:
        use_ghb = True

    idomain = gr.const(1, dtype=int)
    hi = gr.const(0.)
    kx = kr[:, np.newaxis, np.newaxis] * gr.const(1)
    kz = kz[:, np.newaxis, np.newaxis] * gr.const(1.)
    ss = ss[:, np.newaxis, np.newaxis] * gr.const(1.)
                
    fq = np.zeros(1, dtype=dtypeQ)
    fq['I'], fq['q'] = gr.NOD[-1, 0, 0], Q
    fq = {0: fq}

    xlim = np.logspace(-2, 6, 2)
    ylim = np.logspace(-4, 1, 2)

    ax = newfig(f"Hantush using {gr.nlay} layers, leakage using {'ghb' if use_ghb else 'c'}",
            r'increasing r <--- $(4 kD /S) (t / r^2)$ ---> increasing t',
            r'$s / (Q / (4 \pi kD))$',
            xscale='log', yscale='log', xlim=xlim, ylim=ylim)

    ir = np.arange(gr.nx + 1)[r < 60][-1]

    for rho in rhos:
        t = r[ir] ** 2 * S / (4 * kD) * um1
        L = r[ir] / rho
        ctop = L ** 2  / kD
        
        if use_ghb:
            ghb = np.zeros(gr.nx * gr.ny, dtype=dtypeGHB)
            ghb['I'], ghb['h'], ghb['C'] = gr.NOD[-1].ravel(), 0., gr.Area.ravel() / ctop
            ghb = {0: ghb}
            c = None
            fh = None
        else:
            fh = np.zeros(gr.nx * gr.ny, dtype=dtypeH)
            fh['I'], fh['h'] = gr.NOD[0].ravel(), 0.
            fh = {0: fh}
            c = gr.const(0.)[:-1]
            c[0] = ctop 
            ghb = None       
        
        out = fdm3t(gr=gr, t=t, k=(kx, kx, kz), ss=ss, c=c, fh=fh, fq=fq, ghb=ghb, hi=hi, idomain=idomain)
        
        um1 = 4 * kD * t  / (S * r[ir] ** 2)
        wh = out['Phi'][:, -1, 0, ir] /(Q  / (4 *np.pi * kD))
        
        ax.plot(um1, wh, '-',                 label=f"numeric fdm, rho={rho:.4g}")
        ax.plot(um1, Wh(1/um1, rho)[0], '--', label=f'Wh(u, rho),  rho={rho:.4g}')

    ax.legend()
    plt.show()
    return ax

def boulton(um1=None, r=None, D=None, kr=None, kz=None, ss=None, rhos=None, **kw):

    kD = (kr[1:] * D[1:]).sum()
    S0  = ss[0] * D[0]
    S1 = (ss[1:] * D[1:]).sum()

    Q = 4 * np.pi * kD

    z = np.hstack((0, -D))

    gr = Grid(r, [-0.5, +0.5], z, axial=True)
    
    idomain = gr.const(1, dtype=int)
        
    ss = ss[:, np.newaxis, np.newaxis] * gr.const(1.)
    kr = kr[:, np.newaxis, np.newaxis] * gr.const(1.)
    kz = kz[:, np.newaxis, np.newaxis] * gr.const(1.)

    hi = gr.const(0.)
    
    fq = np.zeros(1, dtype=dtypeQ)
    fq['I'], fq['q'] = gr.NOD[-1, 0, 0], Q
    fq = {0: fq}

    xlim = np.logspace(-2, 7, 2)
    ylim = np.logspace(-4, 2, 2)

    ax = newfig(kw['title'] + f", no fixed heads, grid shape = {gr.shape}, ",
            r'increasing r <--- $(4 kD /S) (t / r^2)$ ---> increasing t',
            r'$s  / (Q / (4 \pi kD))$',
            xscale='log', yscale='log', xlim=xlim, ylim=ylim)

    ax.plot(um1,          exp1(1/um1), 'r.-',  lw=2, label=f'Theis Sy = {S0:.4g}')
    ax.plot(um1 * S0 /S1, exp1(1/um1), 'r.--', lw=2, label=f'Theis S  = {S1:.4g}')

    ir = np.arange(gr.nx + 1)[r < 60][-1]

    clrs = color_cycler()
    for rho in rhos:
        clr = next(clrs)
        t = r[ir] ** 2 * S1 / (4 * kD) * um1
        B = r[ir] / rho
        ctop = B ** 2  / kD     
        
        c = gr.const(0.)[:-1]
        c[0] = ctop

        out = fdm3t(gr=gr, t=t, k=(kr, kr, kz), ss=ss, fh=None,
                    fq=fq, hi=hi, idomain=idomain, c=c, ghb=None, epsilon=1.0)

        ax.plot(um1, out['Phi'][:, -1, 0, ir],  color=clr, label=f"Phi[:,-1,0,{ir}], rho={rho:.4g}")            
        ax.plot(um1, Wh(1/um1, rho)[0], '--', color=clr, label=f"Wh(u, rho),     rho={rho:.4g}")

    ax.legend()
    plt.show()
    return ax

def brug223_02(t=None, r=None, D=None, kr=None, kz=None, ss=None, **kw):
    """Return solution of Bruggeman 223_02, in a one-layer axially symmetric model.
    
    The problem is flow  outside a cyling with radius R afger sudden head change at R.    
    """    
    kD = (kr * D).sum()
    S  = (ss * D).sum()
    
    z = -np.cumsum(np.hstack((0, D)))
    gr = Grid(r, [-0.5, 0.5], z, axial=True)
    
    kr = kr[:, np.newaxis, np.newaxis] * gr.const(1.)
    kz = kz[:, np.newaxis, np.newaxis] * gr.const(1.)
    ss = ss[:, np.newaxis, np.newaxis] * gr.const(1.)
    
    idomain = gr.const(1, dtype=int)

    s0 = 1.0
    hi = gr.const(0.)
    #hi[:, :, 0] = s0
    
    
    fh = np.zeros(gr.nz * gr.ny, dtype=dtypeH)
    fh['I'], fh['h'] = gr.NOD[:, :, 0].ravel(), s0
    fh = {0: fh}
    
    out = fdm3t(gr=gr, t=t, k=(kr, kr, kz), ss=ss, fh=fh, fq=None, hi=hi, idomain=idomain)

    xlim = np.logspace(np.log10(t[0]), np.log10(t[-1]), 2)
    ylim = np.logspace(-4, 1, 2)
    
    # The head change s
    ax = newfig(kw['title'],
        't [d]',
        's [m]',
        xscale='log', yscale='log',
        xlim=xlim, ylim=ylim)
    
    cc = color_cycler()
    # select a few distances for which the show the graph
    for ir in np.hstack((0, 1, 2, 3, 4, np.arange(5, gr.nx, 5))):
        if gr.xm[ir] > 100:
            continue
        color = next(cc)                
        ax.plot(t, out['Phi'][:, -1, 0, ir], '-', color=color, label=f'r={gr.xm[ir]:.3g} m')
               
    ax.legend()
    
    # The flow Q
    ylim = np.logspace(0, 5, 2)
    
    ax = newfig(kw['title'] + "Flow Q [m3/d]",
        't [d]',
        'Q [m3/d]',
        xscale='log', yscale='log',
        xlim=xlim, ylim=ylim)
    
    cc = color_cycler()
    # select a few distances for which the show the graph
    for ir in np.hstack((0, 1, 2, 3, 4, np.arange(5, gr.nx, 5))):
        if gr.xm[ir] > 1000:
            continue
        color = next(cc)                
        ax.plot(t[1:], out['Qx'][:, -1, 0, ir], '-', color=color, label=f'r={gr.x[ir]:.3g} m')
               
    ax.legend()

    
    return ax


if __name__ == '__main__':
        
    cases = {
        'steady':
            {'title': 'steady',
             "comment": """This test is to verify the accuracy of the model against an analytical
             solution of Theis or even Hantush by a regular simulation, no dimensionless parameters.
             """,
            't': np.logspace(-4, 9, 131),
            'r': np.hstack((0, np.logspace(-2, 6, 81))),
            'D': np.array([  10., 50.]),
            'kr': np.array([ 1e-6, 10.]),
            'kz': np.array([ 1e6,  1e6]),
            'Ss': np.array([ 0.01, 0.2e-6]),
            'c': np.array([600.]),
            'use_ghb': True,
             },
        'Theis':
            {'title': r"""Theis numeric vs um1 = 1/u. Increasing um1 --> increasing time --> decreasing r.
             Curves for different r overlap due to the choice of both axes which yieldds the Theis type curve.
             Small deviations with the analytic type curve occur only for very large r or very small t.
             """,
             'comment': """Theis numeric.
             Computes the theis type curve by plotting s / (Q / (4 pi kD) vs 4 kD / S * t / r^2
             and compare this with the real theis function exp1.
             """,
            'um1': np.logspace(-5, 9, 141), # um1 = 1/ u
            'r': np.hstack((0., np.logspace(-2, 6, 381))),
            'D': np.array([50.]),
            'kr': np.array([10.]),
            'kz': np.array([1e6]),
            'ss': np.array([1e-5]),
            },
        'Hantush1L':
            {'title' : 'Hantush using 1 layer',
            'comment': """Hantush is numerically simlated using a single model layer, the inflow
            at the top is made using general head boundaries. This result should be the same
            as the one alled Hantush 2L. It's a way to verify that the GHB has been implemented correctly.
            """,
            'um1': np.logspace(-3, 3, 71), # um1 = 1/ u
            'r': np.hstack((0., np.logspace(-2, 6, 81))),
            'D': np.array([20.]),
            'kr': np.array([10.]),
            'kz': np.array([1e6]),
            'ss': np.array([0.2e-6]),                              
            'rhos': [0.01, 0.03, .1, .3, 1., 3.],
            },
        'Hantush2L': {
            'title': 'Hantush using 2 layers',
            'comment': """Hantush is simulated using 2 layer. One is the top layer with fixed head and
            given resistance between the first and second layer. The second layer is the aquifer. This
            example also serves to verify the implementation of the interlayer resistance 'c'.
            """,
            'um1': np.logspace(-5, 9, 141), # um1 = 1/ u
            'r': np.hstack((0., np.logspace(-2, 6, 581))),
            'D': np.array([10., 20.]),
            'kr': np.array([ 1e-6, 1e1]),
            'kz': np.array([ 1e6,  1e6]),
            'ss': np.array([   0., 1e-5]),            
            'rhos': [0.01, 0.03, .1, .3, 1., 3.],
            'use_ghb': False,
            },
        'Boulton63': {
            'title': 'Boulton 1963, delayed yield',
            'comment': """Boulton is simulated using 2 layers. One is the top layer with given Sy and
            given resistance between the first and second layer. The second layer is the aquifer with
            elastic storage coefficient S. The resisance between the two layers follows from the
            value of rho used. A single reference distance r_ is used for all curve. This has no effect
            on the results because these are given on dimensionless graphs.
            """,
            'um1': np.logspace(-5, 9, 141), # um1 = 1/ u
            'r': np.hstack((0., np.logspace(-2, 6, 581))),
            'D': np.array([10., 50.]),
            'kr': np.array([ 1e-6, 10.]),
            'kz': np.array([ 1e6,  1e6]),
            'ss': np.array([  0.01, 0.2e-6]),            
            'rhos': [0.01, 0.03, .1, .3, 1., 3.],
            },
        'Brug223_02': {
            'title': """Burggeman (1999) solution 223.02. Sudden change of head at r=R.
             This solution is very difficult to correctly evaluate analytically""",             
             'comment': """Same as Theis but sudden head change at cylinder with r=R.""",
            't': np.logspace(-3, 3, 141), # um1 = 1/ u
            'r': np.hstack((30. - 0.01, np.logspace(np.log10(30.), 6, 181))),
            'D': np.array([100.]),
            'kr': np.array([10.]),
            'kz': np.array([1e6]),
            'ss': np.array([1e-3]),
            },

        }
    print(f'Available cases:\n{cases.keys()}')
    #deGlee(**cases['steady'])
    #theis1(**cases['Theis'])
    #hantush(**cases['Hantush1L']) # for S=0 -> steady De Glee
    #hantush(**cases['Hantush2L'])
    #boulton(**cases['Boulton63'])
    brug223_02(**cases['Brug223_02'])

    plt.show()